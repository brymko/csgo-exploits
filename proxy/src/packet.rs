use crate::bitutils::{BitReader, BitWriter};
use crate::ice;
use crate::lzss;
use crate::netmessages::*;
use prost::Message;
use std::cell::Cell;
use std::convert::TryInto;
use std::io::Cursor;

const NET_HEADER_FLAG_SPLITPACKET: i32 = -2;
pub const CONNECTIONLESS_HEADER: i32 = -1;
const NET_HEADER_FLAG_COMPRESSEDPACKET: i32 = -3;
const MIN_USER_MAXROUTABLE_SIZE: i32 = 576;
const MIN_SPLIT_SIZE: i32 = (MIN_USER_MAXROUTABLE_SIZE - 12);
const MAX_ROUTABLE_PAYLOAD: i32 = 1200;
const MAX_USER_MAXROUTABLE_SIZE: i32 = MAX_ROUTABLE_PAYLOAD;
const MAX_SPLIT_SIZE: i32 = (MAX_USER_MAXROUTABLE_SIZE - 12);
const NET_MAX_PAYLOAD: i32 = 0x3fffc;
const HEADER_BYTES: i32 = 9;
const NET_MAX_MESSAGE: i32 = NET_MAX_PAYLOAD + HEADER_BYTES + 11;
const MAX_SPLITPACKET_SPLITS: i32 = (NET_MAX_MESSAGE / MIN_SPLIT_SIZE);

const PACKET_FLAG_CHOKED: u8 = (1 << 4);
const PACKET_FLAG_RELIABLE: u8 = (1 << 0);
const MAX_STREAMS: usize = 2;

const FRAGMENT_BITS: usize = 8;
const MAX_FILE_SIZE_BITS: usize = 26;
const FRAGMENT_SIZE: usize = (1 << FRAGMENT_BITS);
const NET_MAX_PAYLOAD_BITS: usize = 18;

fn flick(data: &[u8]) -> Option<Vec<u8>> {
    let num_rand_fudge = data[0] as usize;
    if num_rand_fudge > 0 && num_rand_fudge + 5 < data.len() {
        let num_bytes_written = u32::from_be_bytes(
            data[num_rand_fudge + 1..num_rand_fudge + 5]
                .try_into()
                .unwrap(),
        ) as usize;

        if num_rand_fudge + 5 + num_bytes_written == data.len() {
            return Some(Vec::from(
                &data[num_rand_fudge + 5..num_rand_fudge + 5 + num_bytes_written],
            ));
        }
        println!(
            "\x1B[31mGot num_rand_fudge: {:?} and num_bytes_written: {:?}\x1B[0m",
            num_rand_fudge, num_bytes_written
        );
        return None;
    }
    println!("\x1B[31mGot num_rand_fudge: {:?}\x1B[0m", num_rand_fudge);

    None
}

fn unpack(data: &[u8]) -> Option<Vec<u8>> {
    let mut reader = BitReader::new(data);
    let mut lzma_header = lzss::LzmaHeader::from_reader(&mut reader)?;
    lzss::decompress_lzss10(&mut reader, lzma_header.actual_size as usize)
}

#[derive(Debug, Clone)]
pub struct ParsedFields {
    pub seq_nr: usize,
    pub ack_nr: usize,
}

#[derive(Debug, Clone)]
struct DataFragment {
    buffer: Vec<u8>,
    is_compressed: bool,
    filename: Option<String>,
    bytes: u32,
    uncompressed_size: Option<u32>,
    num_frags: u32,
    acked_frags: u32,
}

impl DataFragment {
    fn new() -> Self {
        DataFragment {
            buffer: Vec::default(),
            is_compressed: false,
            filename: None,
            bytes: 0,
            uncompressed_size: None,
            num_frags: 0,
            acked_frags: 0,
        }
    }
}

struct LongPacket {
    current_sq: Option<i32>,
    split_count: i16,
    total_size: i32,
    expected_split_size: i16,
    //buffer: [u8; NET_MAX_MESSAGE as usize],
    buffer: Vec<Vec<u8>>,
}

impl Default for LongPacket {
    fn default() -> Self {
        Self {
            current_sq: None,
            split_count: 0,
            total_size: 0,
            expected_split_size: 0,
            buffer: Vec::new(),
        }
    }
}

struct SplitPacketEntry {
    //splitflags: [i32; MAX_SPLITPACKET_SPLITS as usize],
    splitflags: Vec<i32>,
    netsplit: LongPacket,
}

impl Default for SplitPacketEntry {
    fn default() -> Self {
        let splitflags = vec![0i32; MAX_SPLITPACKET_SPLITS as usize];
        Self {
            splitflags,
            netsplit: LongPacket::default(),
        }
    }
}

#[repr(packed(1))]
#[derive(Debug, Copy, Clone)]
pub struct Splitpacket {
    pub net_id: i32,
    pub sq_num: i32,
    pub packet_id: u16,
    pub split_size: i16,
}

impl Splitpacket {
    fn from_reader(reader: &BitReader) -> Self {
        let mut clone_reader = reader.clone();
        let net_id = clone_reader.read_var_int32().unwrap();
        let sq_num = clone_reader.read_var_int32().unwrap();
        let packet_id =
            unsafe { core::mem::transmute::<i16, _>(clone_reader.read_short().unwrap()) };
        let split_size = clone_reader.read_short().unwrap();

        Self {
            net_id,
            sq_num,
            packet_id,
            split_size,
        }
    }

    /// Returns the packetnumber of this split packet. This is encoded in the
    /// high byte of the packet_id.
    fn packet_number(&self) -> u8 {
        (self.packet_id >> 8) as u8
    }

    /// Returns the number of total split packets.
    fn packet_count(&self) -> u8 {
        (self.packet_id & 0xff) as u8
    }

    pub fn as_arr(&self) -> [u8; 3 * 4] {
        let mut ret = [0u8; 3 * 4];

        ret[..4].clone_from_slice(self.net_id.to_ne_bytes().as_ref());
        ret[4..8].clone_from_slice(self.sq_num.to_ne_bytes().as_ref());
        ret[8..10].clone_from_slice(self.packet_id.to_ne_bytes().as_ref());
        ret[10..12].clone_from_slice(self.split_size.to_ne_bytes().as_ref());

        ret
    }
}

#[derive(Debug, Clone, Copy)]
pub struct ParseResult {
    pub seq_nr: i32,
    pub ack_nr: i32,
    pub flags: u8,
    pub rel_state: u8,
}

pub struct Parser {
    pub packet: Vec<u8>,
    // This is for split packets.
    split_packet_entry: Option<Cell<SplitPacketEntry>>,
    // This is for non-single block subchannel data.
    data_fragments: Option<Cell<DataFragment>>,
    ice: ice::Ice,
}

impl Parser {
    pub fn new(csgo_version: u32) -> Self {
        Self {
            packet: Vec::new(),
            split_packet_entry: None,
            data_fragments: None,
            ice: ice::Ice::new(csgo_version),
        }
    }

    pub fn on_packet(&mut self, packet: &[u8]) -> Option<ParseResult> {
        // starting in engine/net_ws.cpp
        self.packet = packet.to_vec();
        let mut reader = BitReader::new(self.packet.as_slice());

        // check for split packet
        // TODO: debug this, should this be in big endian?
        let magic = reader.read_long()?;

        // Handle split packets. This just captures the split packets until they are fully
        // assembled at which point this returns a full packet that is then further processed.
        if magic == NET_HEADER_FLAG_SPLITPACKET {
            if let Some(packet) = self.parse_split_packet() {
                // we got a fully assembled packet. This should now be parsed like a regular
                // packet.
                self.packet = packet;
            } else {
                return None;
            }
        }

        if magic == CONNECTIONLESS_HEADER {
            self.parse_connectionless();
            return None;
        }

        // net channel packet aka is encrypted
        let decrypted = self.ice.decrypt(self.packet.as_slice())?;
        // TODO: overwrite self.packet with decrypted ?

        // throw away padding chars used to align encryption
        let decrypted = flick(decrypted.as_slice())?;

        let mut reader = BitReader::new(decrypted.as_slice());

        let magic = reader.peek_long()?;
        let packet = if magic == NET_HEADER_FLAG_COMPRESSEDPACKET {
            self.decompress(&mut reader)?
        } else {
            // packet not compressed return the decrypted stuff
            decrypted
        };

        // set processed packet as cur packet
        self.packet = packet;

        // we are in engine/net_chan.cpp#2848 ProcessPacket(packet, true) // true means we have
        // header enabled

        // packet uncompressed
        let mut reader = BitReader::new(self.packet.as_slice());

        // process only necessary headers for now
        let seq_nr = reader.read_long()?;
        let ack_nr = reader.read_long()?;
        let flags = reader.read_byte()?;

        let _checksum = reader.read_ubit_long(16);
        // we don't really care about the checksum, bitflips on local network shouldn't happen anyways

        let rel_state = reader.read_byte()?;

        let ret = ParseResult {
            seq_nr,
            ack_nr,
            flags,
            rel_state,
        };

        Some(ret)
    }

    /// This does some basic parsing of the message, this should return something meaningful for
    /// display maybe?
    pub fn parse_connectionless(&mut self) -> Option<Vec<u8>> {
        let mut reader = BitReader::new(self.packet.as_slice());

        assert!(reader.read_long()? == CONNECTIONLESS_HEADER);

        let typ = reader.read_byte()?;

        match typ {
            S2C_CONNECTION => {
                println!("GOT S2C Connection packet");
            }
            S2C_CHALLENGE => {
                println!("GOT S2C Challenge packet");
            }
            A2A_PRINT => {
                println!("GOT A2A Print packet");
            }
            S2C_CONNREJECT => {
                println!("GOT S2C Connection reject packet");
            }
            A2A_PING => {
                println!("GOT A2A Ping packet");
            }
            A2A_ACK => {
                println!("GOT A2A Ack packet");
            }
            A2A_CUSTOM => {
                println!("GOT A2A Custom packet");
            }
            S2A_RESERVE_RESPONSE => {
                println!("GOT S2A Reserve packet");
            }
            S2A_RESERVE_CHECK_RESPONSE => {
                println!("GOT S2A Reserve check packet");
            }
            S2A_PING_RESPONSE => {
                println!("GOT S2A Ping response packet");
            }
            S2A_INFO_SRC => {
                println!("GOT S2A Info src packet");
            }

            _ => {
                println!("Got Unknown packet of type {}", typ);
            }
        }

        None
    }

    /// Lzss decompresses a packet given a `BitReader`.
    pub fn decompress(&self, reader: &mut BitReader) -> Option<Vec<u8>> {
        assert!(reader.read_long()? == NET_HEADER_FLAG_COMPRESSEDPACKET);

        // Parse the LZMA header
        let lzma_header = lzss::LzmaHeader::from_reader(reader)?;
        lzss::decompress_lzss10(reader, lzma_header.actual_size as usize)
    }

    /// Try to assemble the split packet.
    /// This function returns either `None`, or the fully assembled packet buffer.
    /// It expects to hold the state across packet receptions.
    pub fn parse_split_packet(&mut self) -> Option<Vec<u8>> {
        let mut reader = BitReader::new(self.packet.as_slice());
        let split_packet_header_size = std::mem::size_of::<Splitpacket>();
        assert!(reader.peek_long()? == NET_HEADER_FLAG_SPLITPACKET);

        // This does not consume from the reader, it instead creates a copy and reads from there.
        let split_packet_header = Splitpacket::from_reader(&mut reader);
        // The remaining packet bytes, without the split packet header.
        let buf = reader.read_bytes(reader.num_bits_left() / 8)?;
        let size = buf.len();

        let packet_number = split_packet_header.packet_number();
        let packet_count = split_packet_header.packet_count();

        //println!("Got {:#?}", split_packet_header);
        //println!("packet_number is {}/{}", packet_number, packet_count);
        // TODO(dezk) assert that we have valid splits.

        // The size of the packet minus the header.
        let split_packet_size =
            split_packet_header.split_size - (std::mem::size_of::<Splitpacket>() as i16);
        println!(
            "Split_packet_size is {} vs. buf.len() is {}",
            split_packet_size,
            buf.len()
        );
        //assert!(buf.len() == split_packet_size as usize);

        // This holds data about our split packet.
        let mut entry: SplitPacketEntry;

        // We have previously already parsed a split packet, so get the entry that holds the
        // previous data.
        if let Some(split_packet_entry) = &self.split_packet_entry {
            entry = split_packet_entry.take();
            // We expect a consistent split size across our split packets.
            assert!(
                entry.netsplit.expected_split_size == split_packet_size,
                "The received packet does not match the expected split size!"
            );
            if entry.splitflags[packet_number as usize] != split_packet_header.sq_num {
                // Is this packet the last packet in this split packet sequence?
                if packet_number == packet_count - 1 {
                    // If so set the size
                    entry.netsplit.total_size = ((packet_count - 1) * split_packet_size as u8
                        + (buf.len() - (std::mem::size_of::<Splitpacket>())) as u8)
                        .into();
                    println!(
                        "Total size of this packet_split should be {}",
                        entry.netsplit.total_size
                    );
                }

                entry.netsplit.split_count -= 1;
                entry.splitflags[packet_number as usize] = split_packet_header.sq_num;
                println!("Got another split packet!");
            } else {
                println!("ignoring duplicated split packet");
            }
        } else {
            // We have not yet received a split packet entry for this split packet, therefore
            // create one.
            entry = SplitPacketEntry::default();
            // This has to be the first packet, therefore we initialize the fields.
            entry.netsplit.current_sq = Some(split_packet_header.sq_num);
            // Already take the currently received packet into account
            entry.netsplit.split_count = (packet_count - 1) as i16;
            entry.netsplit.expected_split_size = split_packet_size;

            // Add one here, as the packet_number is the index into the buffer.
            // And the packet_count is also 0 based.
            entry
                .netsplit
                .buffer
                .resize(packet_count as usize + 1, vec![]);
        }

        // Extend the specific slot that we received with our contents.
        entry.netsplit.buffer[packet_number as usize].extend_from_slice(&buf);

        // Did we receive all the splits?
        if entry.netsplit.split_count <= 0 {
            // Collect all the splits into one vector.
            let packet_buffer: Vec<u8> = entry.netsplit.buffer.into_iter().flatten().collect();
            // Check that the total size matches our calculations.
            assert!(packet_buffer.len() == entry.netsplit.total_size as usize);
            // Reset our split packet state.
            self.split_packet_entry = None;
            Some(packet_buffer)
        } else {
            //println!("Bytes are {:02x?}", buf);
            // Set our entry back into the state.
            // As we either take from the state if we had one, or we
            self.split_packet_entry = Some(Cell::new(entry));
            None
        }
    }

    pub fn dump_client_message(&mut self) -> Option<()> {
        let clony_mc_cloneface = self.packet.clone();
        let mut reader = BitReader::new(clony_mc_cloneface.as_slice());
        let flags = parse_packet_headers(&mut reader)?;

        if flags & PACKET_FLAG_RELIABLE == 0 {
            let buff = reader.read_bytes(reader.num_bits_left() / 8)?;
            //println!("\x1B[32mGot nmsg: {:?}\x1B[0m", buff);
            let mut reader = BitReader::new(buff.as_ref());
            self.print_client_msg(&mut reader);
            return Some(());
        }

        let _bit = reader.read_ubit_long(3)?;

        // 0 == regular stream subchannel
        // 1 == file stream data
        for i in 0..2 {
            if reader.read_one_bit()? == 1 {
                let subchandata = self.read_subchanneldata(&mut reader, i)?;
                let mut msg_reader = BitReader::new(subchandata.as_ref());
                self.print_client_msg(&mut msg_reader);
            }
        }

        while reader.num_bits_left() > 8 {
            self.print_client_msg(&mut reader);
        }

        Some(())
    }

    pub fn dump_server_message(&mut self) -> Option<()> {
        let clony_mc_cloneface = self.packet.clone();
        let mut reader = BitReader::new(clony_mc_cloneface.as_slice());
        let flags = parse_packet_headers(&mut reader)?;

        if flags & PACKET_FLAG_RELIABLE == 0 {
            let buff = reader.read_bytes(reader.num_bits_left() / 8)?;
            //println!("\x1B[32mGot nmsg: {:?}\x1B[0m", buff);
            let mut reader = BitReader::new(buff.as_ref());
            self.print_server_msg(&mut reader);
            return Some(());
        }

        let _bit = reader.read_ubit_long(3)?;

        // 0 == regular stream subchannel
        // 1 == file stream data
        for i in 0..2 {
            if reader.read_one_bit()? == 1 {
                let subchandata = self.read_subchanneldata(&mut reader, i)?;
                //println!(
                //"\x1B[32mGot reliable nmsg: {:?}\npacket: {:?}\x1B[0m",
                //subchandata, self.packet
                //);
                let mut msg_reader = BitReader::new(subchandata.as_ref());
                self.print_server_msg(&mut msg_reader);
            }
        }

        while reader.num_bits_left() > 8 {
            self.print_server_msg(&mut reader);
        }

        Some(())
    }

    fn print_client_msg(&mut self, reader: &mut BitReader) {
        // Consume all the bits
        let buff = reader.read_bytes(reader.num_bits_left() / 8).unwrap();

        let mut reader_nmsg = BitReader::new(buff.as_ref());
        let mut reader_cmsg = BitReader::new(buff.as_ref());

        if let Some(nmsg) = parse_netmsg(&mut reader_nmsg) {
            println!("C2S: NetMsg: {:02x?}", nmsg);
        } else if let Some(cmsg) = parse_clcmsg(&mut reader_cmsg) {
            println!("C2S: ClcMsg: {:02x?}", cmsg);
        } else {
            //println!("\x1b[35mGOT UNHANDLED MSG!\x1b[0m");
        }
    }

    fn print_server_msg(&mut self, reader: &mut BitReader) {
        // Consume all the bits
        let buff = reader.read_bytes(reader.num_bits_left() / 8).unwrap();

        let mut reader_nmsg = BitReader::new(buff.as_ref());
        let mut reader_smsg = BitReader::new(buff.as_ref());

        if let Some(nmsg) = parse_netmsg(&mut reader_nmsg) {
            println!("S2C: NetMsg: {:02x?}", nmsg);
        } else if let Some(smsg) = parse_svcmsg(&mut reader_smsg) {
            println!("S2C: SvcMsg: {:02x?}", smsg);
        } else {
            //println!("\x1b[35mGOT UNHANDLED MSG!\x1b[0m");
        }
    }

    /// Reads the subchannel data.
    /// TODO: Give this a state just like parse_split_packet which is updated depending on the
    /// subchannel data. This allows for non-single block parsing.
    fn read_subchanneldata(&mut self, reader: &mut BitReader, subchanid: usize) -> Option<Vec<u8>> {
        let single_block = reader.read_one_bit()? == 0;
        if !single_block {
            println!(
                "\x1B[33mGot non single block in regular stream: {{...}} len: {:?}\x1B[0m",
                // self.packet,
                self.packet.len()
            );

            let start_fragment = reader.read_ubit_long(MAX_FILE_SIZE_BITS - FRAGMENT_BITS)?;
            let num_fragments = reader.read_ubit_long(3)?;
            let offset = start_fragment * FRAGMENT_SIZE as u32;
            let length = num_fragments * FRAGMENT_SIZE as u32;

            let is_file = reader.read_one_bit()? == 1;

            if is_file {
                let _transfer_id = reader.read_ubit_long(32);
                let _file_name = reader.read_string()?;

                let _is_replay_demo_file = reader.read_one_bit()?;
            }

            let is_compressed = reader.read_one_bit()? == 1;

            if is_compressed {
                let _compressed = true;
                let uncompressed_size = reader.read_ubit_long(MAX_FILE_SIZE_BITS)?;
            }

            let data_bytes = reader.read_ubit_long(MAX_FILE_SIZE_BITS);

            return None;
        }

        let _is_compressed = reader.read_one_bit()? == 1; // is actaully never compressed lol
        let num_bytes = reader.read_ubit_long(NET_MAX_PAYLOAD_BITS)?;
        let num_bits = num_bytes * 8;
        let num_frags = bytes_to_fragment(num_bytes);

        if num_frags == 0 {
            println!("\x1B[31mWTF got 0 num frags\x1B[0m");
            return None;
        }

        let mut length = num_frags * FRAGMENT_SIZE as u32;

        let rest = FRAGMENT_SIZE as u32 - (num_bytes % FRAGMENT_SIZE as u32);
        if rest < FRAGMENT_SIZE as u32 {
            length -= rest;
        }

        // TODO(brymko): for whatever reason when we are in the regular stream we read one more bit
        // i could reverse it but tbh i don't really care. I handled the same issue when parsing
        // the file transfer by adding an additional read.
        // TODO(brymko): this maybe already be correct, but parising files is not yet implemented
        // in this code anyways.
        if subchanid == 0 {
            reader.read_one_bit()?;
        }

        reader.read_bytes(length as usize)
    }
}

/// Try to convert the data in the buffer into a bi-directional NetMessage.
fn parse_netmsg(reader: &mut BitReader) -> Option<NetMessageContainer> {
    //let mut reader = BitReader::new(&buf);
    let cmd = reader.read_var_int32()?;

    let buffer_size = reader.read_var_int32()?;
    let buf = reader.read_bytes(buffer_size as usize)?;

    // Try to convert the i32 into the corresponding NetMessage type.
    let message_type;
    if let Some(typ) = NetMessages::from_i32(cmd) {
        message_type = typ;
    } else {
        // early bail if the netmessage can not be handled yet.
        //panic!("NetMessages::from_i32: Got unhandled NetMessage of type {}", cmd);
        return None;
    }

    // Try to parse it as a netmessage, these are bi-directional.
    Some(match message_type {
        // 0
        // NOTE: These are uninteresting
        //NetMessages::NetNop => NetMessageContainer::NetNop(CnetMsgNop::decode(&*buf).ok()?),
        // 1
        NetMessages::NetDisconnect => {
            NetMessageContainer::NetDisconnect(CnetMsgDisconnect::decode(&*buf).ok()?)
        }
        // 2
        NetMessages::NetFile => NetMessageContainer::NetFile(CnetMsgFile::decode(&*buf).ok()?),
        // 3
        NetMessages::NetSplitScreenUser => {
            NetMessageContainer::NetSplitScreenUser(CnetMsgSplitScreenUser::decode(&*buf).ok()?)
        }
        // 4
        // NOTE: just a lot of data
        //NetMessages::NetTick => NetMessageContainer::NetTick(CnetMsgTick::decode(&*buf).ok()?),
        // 5
        NetMessages::NetStringCmd => {
            NetMessageContainer::NetStringCmd(CnetMsgStringCmd::decode(&*buf).ok()?)
        }
        // 6
        NetMessages::NetSetConVar => {
            NetMessageContainer::NetSetConVar(CnetMsgSetConVar::decode(&*buf).ok()?)
        }
        // 7
        NetMessages::NetSignonState => {
            NetMessageContainer::NetSignonState(CnetMsgSignonState::decode(&*buf).ok()?)
        }
        // 100
        NetMessages::NetPlayerAvatarData => {
            NetMessageContainer::NetPlayerAvatarData(CnetMsgPlayerAvatarData::decode(&*buf).ok()?)
        }
        _ => return None,
    })
}

/// Try to convert the data in the buffer into a client2server ClcMessage.
fn parse_clcmsg(reader: &mut BitReader) -> Option<NetMessageContainer> {
    let cmd = reader.read_var_int32()?;
    let buffer_size = reader.read_var_int32()?;

    let buf = reader.read_bytes(buffer_size as usize)?;

    // Try to convert the i32 into the corresponding ClcMessage type.
    let message_type;
    if let Some(typ) = ClcMessages::from_i32(cmd) {
        message_type = typ;
    } else {
        // early bail if the clcmessage can not be handled yet.
        if NetMessages::from_i32(cmd).is_some() {
            return None;
        }
        println!("\x1b[5m\x1b[1m\x1b[31mClcMessages::from_i32: Got unhandled ClcMessage of type {}\x1b[0m", cmd);
        return None;
    }

    Some(match message_type {
        // 8
        ClcMessages::ClcClientInfo => {
            NetMessageContainer::ClcClientInfo(CclcMsgClientInfo::decode(&*buf).ok()?)
        }
        // 9
        // NOTE: TO MUCH SPEW
        //ClcMessages::ClcMove => NetMessageContainer::ClcMove(CclcMsgMove::decode(&*buf).ok()?),
        // 10
        ClcMessages::ClcVoiceData => {
            NetMessageContainer::ClcVoiceData(CclcMsgVoiceData::decode(&*buf).ok()?)
        }
        // 11
        // NOTE: NOT REALLY INTERESTING
        //ClcMessages::ClcBaselineAck => NetMessageContainer::ClcBaselineAck(CclcMsgBaselineAck::decode(&*buf).ok()?),
        // 12
        ClcMessages::ClcListenEvents => {
            NetMessageContainer::ClcListenEvents(CclcMsgListenEvents::decode(&*buf).ok()?)
        }
        // 13
        ClcMessages::ClcRespondCvarValue => {
            NetMessageContainer::ClcRespondCvarValue(CclcMsgRespondCvarValue::decode(&*buf).ok()?)
        }
        // 14
        // NOTE: TO MUCH SPEW
        //ClcMessages::ClcFileCrcCheck => NetMessageContainer::ClcFileCrcCheck(CclcMsgFileCrcCheck::decode(&*buf).ok()?),
        // 15
        ClcMessages::ClcLoadingProgress => {
            NetMessageContainer::ClcLoadingProgress(CclcMsgLoadingProgress::decode(&*buf).ok()?)
        }
        // 16
        ClcMessages::ClcSplitPlayerConnect => NetMessageContainer::ClcSplitPlayerConnect(
            CclcMsgSplitPlayerConnect::decode(&*buf).ok()?,
        ),
        // 17
        ClcMessages::ClcClientMessage => {
            println!(
                "\x1b[33mGot ClcClientMessage!\nWe do not have its protobuf description.\x1b[0m"
            );
            return None;
        }
        // 18
        ClcMessages::ClcCmdKeyValues => {
            NetMessageContainer::ClcCmdKeyValues(CclcMsgCmdKeyValues::decode(&*buf).ok()?)
        }
        // 20
        ClcMessages::ClcHltvReplay => {
            NetMessageContainer::ClcHltvReplay(CclcMsgHltvReplay::decode(&*buf).ok()?)
        }
        _ => return None,
    })
}

/// Try to convert the data in the buffer into a server2client SvcMessage.
fn parse_svcmsg(reader: &mut BitReader) -> Option<NetMessageContainer> {
    let cmd = reader.read_var_int32()?;
    let buffer_size = reader.read_var_int32()?;

    let buf = reader.read_bytes(buffer_size as usize)?;
    // Try to convert the i32 into the corresponding SvcMessage type.
    let message_type;
    if let Some(typ) = SvcMessages::from_i32(cmd) {
        message_type = typ;
    } else {
        // early bail if the svcmessage can not be handled yet.
        if NetMessages::from_i32(cmd).is_some() {
            return None;
        }
        println!("\x1b[5m\x1b[1m\x1b[31mSvcMessages::from_i32: Got unhandled SvcMessage of type {}\x1b[0m", cmd);
        return None;
    }

    Some(match message_type {
        // NOTE: These messages also start at 8, it therefore depends on the direction of the
        // capture packet to determine which message it actually is.
        // 8
        SvcMessages::SvcServerInfo => {
            NetMessageContainer::SvcServerInfo(CsvcMsgServerInfo::decode(&*buf).ok()?)
        }
        // 9
        SvcMessages::SvcSendTable => {
            NetMessageContainer::SvcSendTable(CsvcMsgSendTable::decode(&*buf).ok()?)
        }
        // 10
        SvcMessages::SvcClassInfo => {
            NetMessageContainer::SvcClassInfo(CsvcMsgClassInfo::decode(&*buf).ok()?)
        }
        // 11
        SvcMessages::SvcSetPause => {
            NetMessageContainer::SvcSetPause(CsvcMsgSetPause::decode(&*buf).ok()?)
        }
        // 12
        SvcMessages::SvcCreateStringTable => {
            NetMessageContainer::SvcCreateStringTable(CsvcMsgCreateStringTable::decode(&*buf).ok()?)
        }
        // 13
        SvcMessages::SvcUpdateStringTable => {
            NetMessageContainer::SvcUpdateStringTable(CsvcMsgUpdateStringTable::decode(&*buf).ok()?)
        }
        // 14
        SvcMessages::SvcVoiceInit => {
            NetMessageContainer::SvcVoiceInit(CsvcMsgVoiceInit::decode(&*buf).ok()?)
        }
        // 15
        SvcMessages::SvcVoiceData => {
            NetMessageContainer::SvcVoiceData(CsvcMsgVoiceData::decode(&*buf).ok()?)
        }
        // 16
        SvcMessages::SvcPrint => NetMessageContainer::SvcPrint(CsvcMsgPrint::decode(&*buf).ok()?),
        // 17
        SvcMessages::SvcSounds => {
            NetMessageContainer::SvcSounds(CsvcMsgSounds::decode(&*buf).ok()?)
        }
        // 18
        SvcMessages::SvcSetView => {
            NetMessageContainer::SvcSetView(CsvcMsgSetView::decode(&*buf).ok()?)
        }
        // 19
        SvcMessages::SvcFixAngle => {
            NetMessageContainer::SvcFixAngle(CsvcMsgFixAngle::decode(&*buf).ok()?)
        }
        // 20
        SvcMessages::SvcCrosshairAngle => {
            NetMessageContainer::SvcCrosshairAngle(CsvcMsgCrosshairAngle::decode(&*buf).ok()?)
        }
        // 21
        SvcMessages::SvcBspDecal => {
            NetMessageContainer::SvcBspDecal(CsvcMsgBspDecal::decode(&*buf).ok()?)
        }
        // 22
        SvcMessages::SvcSplitScreen => {
            NetMessageContainer::SvcSplitScreen(CsvcMsgSplitScreen::decode(&*buf).ok()?)
        }
        // 23
        SvcMessages::SvcUserMessage => {
            NetMessageContainer::SvcUserMessage(CsvcMsgUserMessage::decode(&*buf).ok()?)
        }
        // 24
        SvcMessages::SvcEntityMessage => {
            NetMessageContainer::SvcEntityMessage(CsvcMsgEntityMsg::decode(&*buf).ok()?)
        }
        // 25
        SvcMessages::SvcGameEvent => {
            NetMessageContainer::SvcGameEvent(CsvcMsgGameEvent::decode(&*buf).ok()?)
        }
        // 26
        SvcMessages::SvcPacketEntities => {
            NetMessageContainer::SvcPacketEntities(CsvcMsgPacketEntities::decode(&*buf).ok()?)
        }
        // 27
        SvcMessages::SvcTempEntities => {
            NetMessageContainer::SvcTempEntities(CsvcMsgTempEntities::decode(&*buf).ok()?)
        }
        // 28
        SvcMessages::SvcPrefetch => {
            NetMessageContainer::SvcPrefetch(CsvcMsgPrefetch::decode(&*buf).ok()?)
        }
        // 29
        SvcMessages::SvcMenu => NetMessageContainer::SvcMenu(CsvcMsgMenu::decode(&*buf).ok()?),
        // 30
        SvcMessages::SvcGameEventList => {
            NetMessageContainer::SvcGameEventList(CsvcMsgGameEventList::decode(&*buf).ok()?)
        }
        // 31
        SvcMessages::SvcGetCvarValue => {
            NetMessageContainer::SvcGetCvarValue(CsvcMsgGetCvarValue::decode(&*buf).ok()?)
        }
        // 33
        SvcMessages::SvcPaintmapData => {
            NetMessageContainer::SvcPaintmapData(CsvcMsgPaintmapData::decode(&*buf).ok()?)
        }
        // 34
        SvcMessages::SvcCmdKeyValues => {
            NetMessageContainer::SvcCmdKeyValues(CsvcMsgCmdKeyValues::decode(&*buf).ok()?)
        }
        // 35
        SvcMessages::SvcEncryptedData => {
            NetMessageContainer::SvcEncryptedData(CsvcMsgEncryptedData::decode(&*buf).ok()?)
        }
        // 36
        SvcMessages::SvcHltvReplay => {
            NetMessageContainer::SvcHltvReplay(CsvcMsgHltvReplay::decode(&*buf).ok()?)
        }
        // 38
        SvcMessages::SvcBroadcastCommand => {
            NetMessageContainer::SvcBroadcastCommand(CsvcMsgBroadcastCommand::decode(&*buf).ok()?)
        }
        _ => return None,
    })
}

// THIS fucking code just matches the actual netmessage type to the underlying protobuf message.
// We need this as we cannot match a msg type to the msg data.
// TODO(dezk): impl Debug or write a gross Match.
#[derive(Debug)]
pub enum NetMessageContainer {
    NetNop(CnetMsgNop),
    NetDisconnect(CnetMsgDisconnect),
    NetFile(CnetMsgFile),
    NetSplitScreenUser(CnetMsgSplitScreenUser),
    NetTick(CnetMsgTick),
    NetStringCmd(CnetMsgStringCmd),
    NetSetConVar(CnetMsgSetConVar),
    NetSignonState(CnetMsgSignonState),
    NetPlayerAvatarData(CnetMsgPlayerAvatarData),
    SvcServerInfo(CsvcMsgServerInfo),
    SvcSendTable(CsvcMsgSendTable),
    SvcClassInfo(CsvcMsgClassInfo),
    SvcSetPause(CsvcMsgSetPause),
    SvcCreateStringTable(CsvcMsgCreateStringTable),
    SvcUpdateStringTable(CsvcMsgUpdateStringTable),
    SvcVoiceInit(CsvcMsgVoiceInit),
    SvcVoiceData(CsvcMsgVoiceData),
    SvcPrint(CsvcMsgPrint),
    SvcSounds(CsvcMsgSounds),
    SvcSetView(CsvcMsgSetView),
    SvcFixAngle(CsvcMsgFixAngle),
    SvcCrosshairAngle(CsvcMsgCrosshairAngle),
    SvcBspDecal(CsvcMsgBspDecal),
    SvcSplitScreen(CsvcMsgSplitScreen),
    SvcUserMessage(CsvcMsgUserMessage),
    SvcEntityMessage(CsvcMsgEntityMsg),
    SvcGameEvent(CsvcMsgGameEvent),
    SvcPacketEntities(CsvcMsgPacketEntities),
    SvcTempEntities(CsvcMsgTempEntities),
    SvcPrefetch(CsvcMsgPrefetch),
    SvcMenu(CsvcMsgMenu),
    SvcGameEventList(CsvcMsgGameEventList),
    SvcGetCvarValue(CsvcMsgGetCvarValue),
    SvcPaintmapData(CsvcMsgPaintmapData),
    SvcCmdKeyValues(CsvcMsgCmdKeyValues),
    SvcEncryptedData(CsvcMsgEncryptedData),
    SvcHltvReplay(CsvcMsgHltvReplay),
    SvcBroadcastCommand(CsvcMsgBroadcastCommand),
    ClcClientInfo(CclcMsgClientInfo),
    ClcMove(CclcMsgMove),
    ClcVoiceData(CclcMsgVoiceData),
    ClcBaselineAck(CclcMsgBaselineAck),
    ClcListenEvents(CclcMsgListenEvents),
    ClcRespondCvarValue(CclcMsgRespondCvarValue),
    ClcFileCrcCheck(CclcMsgFileCrcCheck),
    ClcLoadingProgress(CclcMsgLoadingProgress),
    ClcSplitPlayerConnect(CclcMsgSplitPlayerConnect),
    //ClcClientMessage(CclcMsgClientMessage),
    ClcCmdKeyValues(CclcMsgCmdKeyValues),
    ClcHltvReplay(CclcMsgHltvReplay),
}

fn parse_packet_headers(reader: &mut BitReader) -> Option<u8> {
    if reader.peek_long() == Some(CONNECTIONLESS_HEADER) {
        return None;
    }
    let seq_nr = reader.read_long()?;
    let ack_nr = reader.read_long()?;
    let flags = reader.read_byte()?;

    // if ShouldChecksumPackets() { // This is alwasy on if NET_IsMultiplayer
    let checksum = reader.read_ubit_long(16);
    // we don't really care about the checksum, bitflips on local network shouldn't happen anyways

    let rel_state = reader.read_byte()?;

    let _choked = if flags & PACKET_FLAG_CHOKED != 0 {
        reader.read_byte()?
    } else {
        0
    };

    if flags == 0xff {
        return None;
    }

    Some(flags)
}

fn crc32_compute_table() -> [u32; 256] {
    let mut crc32_table = [0; 256];

    for n in 0..256 {
        crc32_table[n as usize] = (0..8).fold(n as u32, |acc, _| match acc & 1 {
            1 => 0xedb88320 ^ (acc >> 1),
            _ => acc >> 1,
        });
    }

    crc32_table
}

fn crc32_single_buffer(buf: &[u8]) -> u32 {
    let crc_table = crc32_compute_table();

    !buf.iter().fold(!0, |acc, octet| {
        (acc >> 8) ^ crc_table[((acc & 0xff) ^ *octet as u32) as usize]
    })
}

fn calc_checksum(buf: &[u8]) -> u16 {
    let checksum = crc32_single_buffer(buf);
    ((checksum & 0xffff) ^ ((checksum >> 16) & 0xffff)) as u16
}

/// this will generate the crc which is needed to pass the checksum check
fn gen_crc(data: &[u8]) -> [u8; 2] {
    let asu16 = calc_checksum(data);
    asu16.to_le_bytes() // i might be mistaken, but i don't think the endianess is defined anywhere
}

fn as_var_int(data: i32) -> Vec<u8> {
    let mut ret = Vec::default();
    let mut idx = 0;
    let mut data = data;

    while data > 0x7f {
        ret.push(((data & 0x7f) | 0x80) as u8);
        data >>= 7;
    }

    ret.push((data & 0x7f) as u8);
    ret
}

/// Create a buffer with length and msg type info
pub fn create_packet_from_data(rel_state: u8, packet_type: u8, svc_msg: &[u8]) -> Vec<u8> {
    let mut encoded_msg = Vec::default();
    encoded_msg.push(rel_state); // needs to be done so we pass the crc check
                                 // Push the packet_type
    encoded_msg.push(packet_type);
    // Add the message length and the actual data.
    encoded_msg.extend_from_slice(&as_var_int(svc_msg.len() as i32)[..]);
    encoded_msg.extend_from_slice(svc_msg);

    encoded_msg
}

/// Add the crc and the seq and seq_ack numbers
pub fn update_seq_ack(msg: &[u8], seq: i32, seq_ack: i32) -> Vec<u8> {
    let mut packet = Vec::default();
    packet.resize(11, 0);
    packet[..4].copy_from_slice(&seq.to_le_bytes());
    packet[4..8].copy_from_slice(&seq_ack.to_le_bytes());
    packet[8] = 0; // flags, we dont want any

    // this is the crc which is build on raw_msg
    packet[9..11].copy_from_slice(&gen_crc(&msg));
    packet.extend_from_slice(msg);

    packet
}

/// Pads the fudges for encryption.
pub fn padd_packet(packet: &[u8]) -> Vec<u8> {
    let padding = 8 - ((packet.len() + 5) % 8);
    let mut fudges: Vec<u8> = Vec::default();
    fudges.push(padding as u8);
    fudges.resize(padding + 1, 99);
    fudges.extend_from_slice(&(packet.len() as i32).to_be_bytes());
    fudges.extend_from_slice(packet);

    fudges
}

pub fn compress_packet(packet: &[u8]) -> Vec<u8> {
    packet.to_vec()
}

fn bytes_to_fragment(b: u32) -> u32 {
    (b + FRAGMENT_SIZE as u32 - 1) / FRAGMENT_SIZE as u32
}
