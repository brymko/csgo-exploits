use crate::bitutils::BitReader;

#[repr(packed)]
#[derive(Debug, Copy, Clone)]
pub struct LzmaHeader {
    id: [char; 4],
    pub actual_size: u32,
}

impl LzmaHeader {
    pub fn from_reader(reader: &mut BitReader) -> Option<Self> {
        let mut id = ['0'; 4];
        id.copy_from_slice(
            &(0..4)
                .map(|_| reader.read_byte().unwrap() as char)
                .collect::<Vec<char>>(),
        ); //(reader.read_long()? as u32).to_ne_bytes();
        assert!(id == ['L', 'Z', 'S', 'S']);

        let actual_size = reader.read_long()? as u32;
        Some(Self { id, actual_size })
    }
}

/// Decompresses an lzss10 compressed packet, given a `BitReader` that is consumed.
/// TODO: This should take a `BitReader` instead of a `&mut BitReader` as it is consumed.
pub fn decompress_lzss10(data: &mut BitReader, size: usize) -> Option<Vec<u8>> {
    let mut decompress_data: Vec<u8> = Vec::new();

    let disp_extra = 1;
    while decompress_data.len() < size {
        let cmd_byte = [data.read_byte()?];
        let cmd_bits = BitReader::new(&cmd_byte);
        // Maybe a bit overkill to impl Iterator for this.
        // Another possibility would be to just do something like this:
        //let cmd_bits = (0u8..8).map(|_| data.read_one_bit().unwrap()).collect::<Vec<u8>>();
        for bit in cmd_bits {
            if bit == 1 {
                let val = u16::from_be_bytes([data.read_byte()?, data.read_byte()?]);
                let count = (val & 0x0F) + 1;
                let disp = ((val & 0xFFF0) >> 4) + disp_extra;
                for _ in 0..count {
                    let len = decompress_data.len();
                    let copy_data = decompress_data[len - disp as usize];
                    decompress_data.push(copy_data);
                }
            } else {
                decompress_data.push(data.read_byte()?);
            }

            if size <= decompress_data.len() {
                break;
            }
        }
    }

    if size == decompress_data.len() {
        Some(decompress_data)
    } else {
        panic!(
            "Decompression Error! Size is {}, got {}",
            size,
            decompress_data.len()
        );
    }
}
