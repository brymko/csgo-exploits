//=============================================================================
// Common Types
//=============================================================================

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgVector {
    #[prost(float, optional, tag = "1")]
    pub x: ::std::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::std::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub z: ::std::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgVector2D {
    #[prost(float, optional, tag = "1")]
    pub x: ::std::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::std::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgQAngle {
    #[prost(float, optional, tag = "1")]
    pub x: ::std::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::std::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub z: ::std::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgRgba {
    #[prost(int32, optional, tag = "1")]
    pub r: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub g: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub b: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub a: ::std::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgTick {
    /// current tick count
    #[prost(uint32, optional, tag = "1")]
    pub tick: ::std::option::Option<u32>,
    /// optional uint32 host_frametime = 2;// Host frame time in 1/100000th of a second
    /// optional uint32 host_frametime_std_deviation = 3;// Host frame time stddev in 1/100000th of a second
    ///
    /// Host frame computation time in usec (1/1,000,000th sec) - will be say 4 ms when server is running at 25% CPU load for 64-tick server
    #[prost(uint32, optional, tag = "4")]
    pub host_computationtime: ::std::option::Option<u32>,
    /// Host frame computation time stddev in usec (1/1,000,000th sec)
    #[prost(uint32, optional, tag = "5")]
    pub host_computationtime_std_deviation: ::std::option::Option<u32>,
    /// Host frame start time stddev in usec (1/1,000,000th sec) - measures how precisely we can wake up from sleep when meeting server framerate
    #[prost(uint32, optional, tag = "6")]
    pub host_framestarttime_std_deviation: ::std::option::Option<u32>,
    /// 0 or absent by default, 1 when hltv replay is in progress - used to fix client state in case of server crashes of full frame updates
    #[prost(uint32, optional, tag = "7")]
    pub hltv_replay_flags: ::std::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgStringCmd {
    #[prost(string, optional, tag = "1")]
    pub command: ::std::option::Option<std::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgSignonState {
    /// See SIGNONSTATE_ defines
    #[prost(uint32, optional, tag = "1")]
    pub signon_state: ::std::option::Option<u32>,
    /// server spawn count (session number)
    #[prost(uint32, optional, tag = "2")]
    pub spawn_count: ::std::option::Option<u32>,
    /// Number of players the server discloses as connected to the server
    #[prost(uint32, optional, tag = "3")]
    pub num_server_players: ::std::option::Option<u32>,
    /// player network ids
    #[prost(string, repeated, tag = "4")]
    pub players_networkids: ::std::vec::Vec<std::string::String>,
    /// Name of the current map
    #[prost(string, optional, tag = "5")]
    pub map_name: ::std::option::Option<std::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgCVars {
    #[prost(message, repeated, tag = "1")]
    pub cvars: ::std::vec::Vec<c_msg_c_vars::CVar>,
}
pub mod c_msg_c_vars {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CVar {
        #[prost(string, optional, tag = "1")]
        pub name: ::std::option::Option<std::string::String>,
        #[prost(string, optional, tag = "2")]
        pub value: ::std::option::Option<std::string::String>,
        /// In order to save on connect packet size convars that are known will have their dictionary name index sent here
        #[prost(uint32, optional, tag = "3")]
        pub dictionary_name: ::std::option::Option<u32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgSetConVar {
    #[prost(message, optional, tag = "1")]
    pub convars: ::std::option::Option<CMsgCVars>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgNop {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgDisconnect {
    #[prost(string, optional, tag = "1")]
    pub text: ::std::option::Option<std::string::String>,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgFile {
    #[prost(int32, optional, tag = "1")]
    pub transfer_id: ::std::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub file_name: ::std::option::Option<std::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub is_replay_demo_file: ::std::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub deny: ::std::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgSplitScreenUser {
    #[prost(int32, optional, tag = "1")]
    pub slot: ::std::option::Option<i32>,
}
/// 12 KB player avatar 64x64 rgb only no alpha
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgPlayerAvatarData {
    /// WARNING-WARNING-WARNING
    /// This message is extremely large for our net channels
    /// and must be pumped through special fragmented waiting list
    /// via chunk-based ack mechanism!
    /// See: INetChannel::EnqueueVeryLargeAsyncTransfer
    /// WARNING-WARNING-WARNING
    #[prost(uint32, optional, tag = "1")]
    pub accountid: ::std::option::Option<u32>,
    #[prost(bytes, optional, tag = "2")]
    pub rgb: ::std::option::Option<std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgClientInfo {
    #[prost(fixed32, optional, tag = "1")]
    pub send_table_crc: ::std::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub server_count: ::std::option::Option<u32>,
    #[prost(bool, optional, tag = "3")]
    pub is_hltv: ::std::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub is_replay: ::std::option::Option<bool>,
    #[prost(uint32, optional, tag = "5")]
    pub friends_id: ::std::option::Option<u32>,
    #[prost(string, optional, tag = "6")]
    pub friends_name: ::std::option::Option<std::string::String>,
    #[prost(fixed32, repeated, packed = "false", tag = "7")]
    pub custom_files: ::std::vec::Vec<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgMove {
    /// new commands = user_cmds_size() - num_backup_commands
    #[prost(uint32, optional, tag = "1")]
    pub num_backup_commands: ::std::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub num_new_commands: ::std::option::Option<u32>,
    #[prost(bytes, optional, tag = "3")]
    pub data: ::std::option::Option<std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgVoiceData {
    #[prost(bytes, optional, tag = "1")]
    pub data: ::std::option::Option<std::vec::Vec<u8>>,
    #[prost(fixed64, optional, tag = "2")]
    pub xuid: ::std::option::Option<u64>,
    #[prost(
        enumeration = "VoiceDataFormatT",
        optional,
        tag = "3",
        default = "VoicedataFormatEngine"
    )]
    pub format: ::std::option::Option<i32>,
    /// This is a TCP-style sequence number, so it includes the current packet length.  So it's actually the offset within the compressed data stream of the next packet to follow (if any).
    #[prost(int32, optional, tag = "4")]
    pub sequence_bytes: ::std::option::Option<i32>,
    #[prost(uint32, optional, tag = "5")]
    pub section_number: ::std::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub uncompressed_sample_offset: ::std::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgBaselineAck {
    #[prost(int32, optional, tag = "1")]
    pub baseline_tick: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub baseline_nr: ::std::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgListenEvents {
    #[prost(fixed32, repeated, packed = "false", tag = "1")]
    pub event_mask: ::std::vec::Vec<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgRespondCvarValue {
    /// QueryCvarCookie_t
    #[prost(int32, optional, tag = "1")]
    pub cookie: ::std::option::Option<i32>,
    /// EQueryCvarValueStatus
    #[prost(int32, optional, tag = "2")]
    pub status_code: ::std::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub name: ::std::option::Option<std::string::String>,
    #[prost(string, optional, tag = "4")]
    pub value: ::std::option::Option<std::string::String>,
}
/// See CCLCMsg_FileCRCCheck_t in netmessages.h while reading this.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgFileCrcCheck {
    // Optimisation:

    // Do not set or get path or filename directly, use instead
    // CCLCMsg_FileCRCCheck_t::GetPath()
    // CCLCMsg_FileCRCCheck_t::GetPath()...etc..

    // If the path and/or filename below is one of certain commonly occuring ones
    // then an index is stored instead of a string. So if code_path != -1 then
    // path == "".
    /// read comment above
    #[prost(int32, optional, tag = "1")]
    pub code_path: ::std::option::Option<i32>,
    /// read comment above
    #[prost(string, optional, tag = "2")]
    pub path: ::std::option::Option<std::string::String>,
    /// read comment above
    #[prost(int32, optional, tag = "3")]
    pub code_filename: ::std::option::Option<i32>,
    /// read comment above
    #[prost(string, optional, tag = "4")]
    pub filename: ::std::option::Option<std::string::String>,
    #[prost(int32, optional, tag = "5")]
    pub file_fraction: ::std::option::Option<i32>,
    #[prost(bytes, optional, tag = "6")]
    pub md5: ::std::option::Option<std::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "7")]
    pub crc: ::std::option::Option<u32>,
    #[prost(int32, optional, tag = "8")]
    pub file_hash_type: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub file_len: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub pack_file_id: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub pack_file_number: ::std::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgLoadingProgress {
    #[prost(int32, optional, tag = "1")]
    pub progress: ::std::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgSplitPlayerConnect {
    #[prost(message, optional, tag = "1")]
    pub convars: ::std::option::Option<CMsgCVars>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgCmdKeyValues {
    #[prost(bytes, optional, tag = "1")]
    pub keyvalues: ::std::option::Option<std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgServerInfo {
    /// protocol version
    #[prost(int32, optional, tag = "1")]
    pub protocol: ::std::option::Option<i32>,
    /// number of changelevels since server start
    #[prost(int32, optional, tag = "2")]
    pub server_count: ::std::option::Option<i32>,
    /// dedicated server ?
    #[prost(bool, optional, tag = "3")]
    pub is_dedicated: ::std::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub is_official_valve_server: ::std::option::Option<bool>,
    /// HLTV server ?
    #[prost(bool, optional, tag = "5")]
    pub is_hltv: ::std::option::Option<bool>,
    /// Replay server ?
    #[prost(bool, optional, tag = "6")]
    pub is_replay: ::std::option::Option<bool>,
    /// // Will be redirecting to proxy relay
    #[prost(bool, optional, tag = "21")]
    pub is_redirecting_to_proxy_relay: ::std::option::Option<bool>,
    /// L = linux, W = Win32
    #[prost(int32, optional, tag = "7")]
    pub c_os: ::std::option::Option<i32>,
    /// server map CRC
    #[prost(fixed32, optional, tag = "8")]
    pub map_crc: ::std::option::Option<u32>,
    /// client.dll CRC server is using
    #[prost(fixed32, optional, tag = "9")]
    pub client_crc: ::std::option::Option<u32>,
    /// string table CRC server is using
    #[prost(fixed32, optional, tag = "10")]
    pub string_table_crc: ::std::option::Option<u32>,
    /// max number of clients on server
    #[prost(int32, optional, tag = "11")]
    pub max_clients: ::std::option::Option<i32>,
    /// max number of server classes
    #[prost(int32, optional, tag = "12")]
    pub max_classes: ::std::option::Option<i32>,
    /// our client slot number
    #[prost(int32, optional, tag = "13")]
    pub player_slot: ::std::option::Option<i32>,
    /// server tick interval
    #[prost(float, optional, tag = "14")]
    pub tick_interval: ::std::option::Option<f32>,
    /// game directory eg "tf2"
    #[prost(string, optional, tag = "15")]
    pub game_dir: ::std::option::Option<std::string::String>,
    /// name of current map
    #[prost(string, optional, tag = "16")]
    pub map_name: ::std::option::Option<std::string::String>,
    /// name of current map
    #[prost(string, optional, tag = "17")]
    pub map_group_name: ::std::option::Option<std::string::String>,
    /// name of current skybox
    #[prost(string, optional, tag = "18")]
    pub sky_name: ::std::option::Option<std::string::String>,
    /// server name
    #[prost(string, optional, tag = "19")]
    pub host_name: ::std::option::Option<std::string::String>,
    #[prost(uint32, optional, tag = "20")]
    pub public_ip: ::std::option::Option<u32>,
    #[prost(uint64, optional, tag = "22")]
    pub ugc_map_id: ::std::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgClassInfo {
    #[prost(bool, optional, tag = "1")]
    pub create_on_client: ::std::option::Option<bool>,
    #[prost(message, repeated, tag = "2")]
    pub classes: ::std::vec::Vec<csvc_msg_class_info::ClassT>,
}
pub mod csvc_msg_class_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClassT {
        #[prost(int32, optional, tag = "1")]
        pub class_id: ::std::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub data_table_name: ::std::option::Option<std::string::String>,
        #[prost(string, optional, tag = "3")]
        pub class_name: ::std::option::Option<std::string::String>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgSendTable {
    #[prost(bool, optional, tag = "1")]
    pub is_end: ::std::option::Option<bool>,
    #[prost(string, optional, tag = "2")]
    pub net_table_name: ::std::option::Option<std::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub needs_decoder: ::std::option::Option<bool>,
    #[prost(message, repeated, tag = "4")]
    pub props: ::std::vec::Vec<csvc_msg_send_table::SendpropT>,
}
pub mod csvc_msg_send_table {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SendpropT {
        /// SendPropType
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::std::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub var_name: ::std::option::Option<std::string::String>,
        #[prost(int32, optional, tag = "3")]
        pub flags: ::std::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub priority: ::std::option::Option<i32>,
        /// if pProp->m_Type == DPT_DataTable || IsExcludeProp
        #[prost(string, optional, tag = "5")]
        pub dt_name: ::std::option::Option<std::string::String>,
        /// else if pProp->m_Type == DPT_Array
        #[prost(int32, optional, tag = "6")]
        pub num_elements: ::std::option::Option<i32>,
        /// else ...
        #[prost(float, optional, tag = "7")]
        pub low_value: ::std::option::Option<f32>,
        /// ...
        #[prost(float, optional, tag = "8")]
        pub high_value: ::std::option::Option<f32>,
        /// ...
        #[prost(int32, optional, tag = "9")]
        pub num_bits: ::std::option::Option<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgPrint {
    #[prost(string, optional, tag = "1")]
    pub text: ::std::option::Option<std::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgSetPause {
    #[prost(bool, optional, tag = "1")]
    pub paused: ::std::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgSetView {
    #[prost(int32, optional, tag = "1")]
    pub entity_index: ::std::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgCreateStringTable {
    #[prost(string, optional, tag = "1")]
    pub name: ::std::option::Option<std::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub max_entries: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub num_entries: ::std::option::Option<i32>,
    #[prost(bool, optional, tag = "4")]
    pub user_data_fixed_size: ::std::option::Option<bool>,
    #[prost(int32, optional, tag = "5")]
    pub user_data_size: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub user_data_size_bits: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub flags: ::std::option::Option<i32>,
    #[prost(bytes, optional, tag = "8")]
    pub string_data: ::std::option::Option<std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgUpdateStringTable {
    #[prost(int32, optional, tag = "1")]
    pub table_id: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub num_changed_entries: ::std::option::Option<i32>,
    #[prost(bytes, optional, tag = "3")]
    pub string_data: ::std::option::Option<std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgVoiceInit {
    #[prost(int32, optional, tag = "1")]
    pub quality: ::std::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub codec: ::std::option::Option<std::string::String>,
    #[prost(int32, optional, tag = "3", default = "0")]
    pub version: ::std::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgVoiceData {
    #[prost(int32, optional, tag = "1")]
    pub client: ::std::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub proximity: ::std::option::Option<bool>,
    #[prost(fixed64, optional, tag = "3")]
    pub xuid: ::std::option::Option<u64>,
    #[prost(int32, optional, tag = "4")]
    pub audible_mask: ::std::option::Option<i32>,
    #[prost(bytes, optional, tag = "5")]
    pub voice_data: ::std::option::Option<std::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "6")]
    pub caster: ::std::option::Option<bool>,
    #[prost(
        enumeration = "VoiceDataFormatT",
        optional,
        tag = "7",
        default = "VoicedataFormatEngine"
    )]
    pub format: ::std::option::Option<i32>,
    /// This is a TCP-style sequence number, so it includes the current packet length.  So it's actually the offset within the compressed data stream of the next packet to follow (if any).
    #[prost(int32, optional, tag = "8")]
    pub sequence_bytes: ::std::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub section_number: ::std::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub uncompressed_sample_offset: ::std::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgFixAngle {
    #[prost(bool, optional, tag = "1")]
    pub relative: ::std::option::Option<bool>,
    #[prost(message, optional, tag = "2")]
    pub angle: ::std::option::Option<CMsgQAngle>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgCrosshairAngle {
    #[prost(message, optional, tag = "1")]
    pub angle: ::std::option::Option<CMsgQAngle>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgPrefetch {
    #[prost(int32, optional, tag = "1")]
    pub sound_index: ::std::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgBspDecal {
    #[prost(message, optional, tag = "1")]
    pub pos: ::std::option::Option<CMsgVector>,
    #[prost(int32, optional, tag = "2")]
    pub decal_texture_index: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub entity_index: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub model_index: ::std::option::Option<i32>,
    #[prost(bool, optional, tag = "5")]
    pub low_priority: ::std::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgSplitScreen {
    #[prost(enumeration = "ESplitScreenMessageType", optional, tag = "1")]
    pub r#type: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub slot: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub player_index: ::std::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgGetCvarValue {
    /// QueryCvarCookie_t
    #[prost(int32, optional, tag = "1")]
    pub cookie: ::std::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub cvar_name: ::std::option::Option<std::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgMenu {
    /// DIALOG_TYPE
    #[prost(int32, optional, tag = "1")]
    pub dialog_type: ::std::option::Option<i32>,
    /// KeyValues.WriteAsBinary()
    #[prost(bytes, optional, tag = "2")]
    pub menu_key_values: ::std::option::Option<std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgUserMessage {
    #[prost(int32, optional, tag = "1")]
    pub msg_type: ::std::option::Option<i32>,
    #[prost(bytes, optional, tag = "2")]
    pub msg_data: ::std::option::Option<std::vec::Vec<u8>>,
    /// 0 or absent = normal event; 1 = pass-through real-time event needed during replay
    #[prost(int32, optional, tag = "3")]
    pub passthrough: ::std::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgPaintmapData {
    #[prost(bytes, optional, tag = "1")]
    pub paintmap: ::std::option::Option<std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgGameEvent {
    #[prost(string, optional, tag = "1")]
    pub event_name: ::std::option::Option<std::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub eventid: ::std::option::Option<i32>,
    #[prost(message, repeated, tag = "3")]
    pub keys: ::std::vec::Vec<csvc_msg_game_event::KeyT>,
    /// 0 or absent = normal event; 1 = pass-through real-time event needed during replay
    #[prost(int32, optional, tag = "4")]
    pub passthrough: ::std::option::Option<i32>,
}
pub mod csvc_msg_game_event {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyT {
        /// type
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::std::option::Option<i32>,
        /// TYPE_STRING
        #[prost(string, optional, tag = "2")]
        pub val_string: ::std::option::Option<std::string::String>,
        /// TYPE_FLOAT
        #[prost(float, optional, tag = "3")]
        pub val_float: ::std::option::Option<f32>,
        /// TYPE_LONG  
        #[prost(int32, optional, tag = "4")]
        pub val_long: ::std::option::Option<i32>,
        /// TYPE_SHORT
        #[prost(int32, optional, tag = "5")]
        pub val_short: ::std::option::Option<i32>,
        /// TYPE_BYTE  
        #[prost(int32, optional, tag = "6")]
        pub val_byte: ::std::option::Option<i32>,
        /// TYPE_BOOL  
        #[prost(bool, optional, tag = "7")]
        pub val_bool: ::std::option::Option<bool>,
        /// TYPE_UINT64
        #[prost(uint64, optional, tag = "8")]
        pub val_uint64: ::std::option::Option<u64>,
        /// TYPE_WSTRING
        #[prost(bytes, optional, tag = "9")]
        pub val_wstring: ::std::option::Option<std::vec::Vec<u8>>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgGameEventList {
    #[prost(message, repeated, tag = "1")]
    pub descriptors: ::std::vec::Vec<csvc_msg_game_event_list::DescriptorT>,
}
pub mod csvc_msg_game_event_list {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyT {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::std::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::std::option::Option<std::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DescriptorT {
        #[prost(int32, optional, tag = "1")]
        pub eventid: ::std::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::std::option::Option<std::string::String>,
        #[prost(message, repeated, tag = "3")]
        pub keys: ::std::vec::Vec<KeyT>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgTempEntities {
    #[prost(bool, optional, tag = "1")]
    pub reliable: ::std::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub num_entries: ::std::option::Option<i32>,
    #[prost(bytes, optional, tag = "3")]
    pub entity_data: ::std::option::Option<std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgPacketEntities {
    #[prost(int32, optional, tag = "1")]
    pub max_entries: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub updated_entries: ::std::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub is_delta: ::std::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub update_baseline: ::std::option::Option<bool>,
    #[prost(int32, optional, tag = "5")]
    pub baseline: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub delta_from: ::std::option::Option<i32>,
    #[prost(bytes, optional, tag = "7")]
    pub entity_data: ::std::option::Option<std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgSounds {
    #[prost(bool, optional, tag = "1")]
    pub reliable_sound: ::std::option::Option<bool>,
    #[prost(message, repeated, tag = "2")]
    pub sounds: ::std::vec::Vec<csvc_msg_sounds::SounddataT>,
}
pub mod csvc_msg_sounds {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SounddataT {
        #[prost(sint32, optional, tag = "1")]
        pub origin_x: ::std::option::Option<i32>,
        #[prost(sint32, optional, tag = "2")]
        pub origin_y: ::std::option::Option<i32>,
        #[prost(sint32, optional, tag = "3")]
        pub origin_z: ::std::option::Option<i32>,
        #[prost(uint32, optional, tag = "4")]
        pub volume: ::std::option::Option<u32>,
        #[prost(float, optional, tag = "5")]
        pub delay_value: ::std::option::Option<f32>,
        #[prost(int32, optional, tag = "6")]
        pub sequence_number: ::std::option::Option<i32>,
        #[prost(int32, optional, tag = "7")]
        pub entity_index: ::std::option::Option<i32>,
        #[prost(int32, optional, tag = "8")]
        pub channel: ::std::option::Option<i32>,
        #[prost(int32, optional, tag = "9")]
        pub pitch: ::std::option::Option<i32>,
        #[prost(int32, optional, tag = "10")]
        pub flags: ::std::option::Option<i32>,
        #[prost(uint32, optional, tag = "11")]
        pub sound_num: ::std::option::Option<u32>,
        #[prost(fixed32, optional, tag = "12")]
        pub sound_num_handle: ::std::option::Option<u32>,
        #[prost(int32, optional, tag = "13")]
        pub speaker_entity: ::std::option::Option<i32>,
        #[prost(int32, optional, tag = "14")]
        pub random_seed: ::std::option::Option<i32>,
        /// soundlevel_t
        #[prost(int32, optional, tag = "15")]
        pub sound_level: ::std::option::Option<i32>,
        #[prost(bool, optional, tag = "16")]
        pub is_sentence: ::std::option::Option<bool>,
        #[prost(bool, optional, tag = "17")]
        pub is_ambient: ::std::option::Option<bool>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgEntityMsg {
    #[prost(int32, optional, tag = "1")]
    pub ent_index: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub class_id: ::std::option::Option<i32>,
    #[prost(bytes, optional, tag = "3")]
    pub ent_data: ::std::option::Option<std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgCmdKeyValues {
    #[prost(bytes, optional, tag = "1")]
    pub keyvalues: ::std::option::Option<std::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgEncryptedData {
    #[prost(bytes, optional, tag = "1")]
    pub encrypted: ::std::option::Option<std::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "2")]
    pub key_type: ::std::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgHltvReplay {
    /// delay in ticks, 0 or abscent if replay stops
    #[prost(int32, optional, tag = "1")]
    pub delay: ::std::option::Option<i32>,
    /// the primary target to look at during the replay
    #[prost(int32, optional, tag = "2")]
    pub primary_target: ::std::option::Option<i32>,
    /// the tick when replay stops, on delayed timeline
    #[prost(int32, optional, tag = "3")]
    pub replay_stop_at: ::std::option::Option<i32>,
    /// the tick when replay starts, on real timeline
    #[prost(int32, optional, tag = "4")]
    pub replay_start_at: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub replay_slowdown_begin: ::std::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub replay_slowdown_end: ::std::option::Option<i32>,
    #[prost(float, optional, tag = "7")]
    pub replay_slowdown_rate: ::std::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgHltvReplay {
    /// 0 = cancel, 1 = request death replay, 2 = request arbitrary replay, 3 = request full frame update because client didn't receive it when expected
    #[prost(int32, optional, tag = "1")]
    pub request: ::std::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub slowdown_length: ::std::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub slowdown_rate: ::std::option::Option<f32>,
    #[prost(int32, optional, tag = "4")]
    pub primary_target_ent_index: ::std::option::Option<i32>,
    #[prost(float, optional, tag = "5")]
    pub event_time: ::std::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgBroadcastCommand {
    #[prost(string, optional, tag = "1")]
    pub cmd: ::std::option::Option<std::string::String>,
}
//=============================================================================
// Bidirectional NET Messages
//=============================================================================

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NetMessages {
    NetNop = 0,
    /// disconnect, last message in connection
    NetDisconnect = 1,
    /// file transmission message request/deny
    NetFile = 2,
    /// Changes split screen user, client and server must both provide handler
    NetSplitScreenUser = 3,
    /// s->c world tick, c->s ack world tick
    NetTick = 4,
    /// a string command
    NetStringCmd = 5,
    /// sends one/multiple convar/userinfo settings
    NetSetConVar = 6,
    /// signals or acks current signon state
    NetSignonState = 7,
    /// client clc messages and server svc messages use the range 8+
    ///
    /// player avatar RGB data (client clc & server svc message blocks use 8..., so start a new range here @ 100+)
    NetPlayerAvatarData = 100,
}
//=============================================================================
// Client messages
//=============================================================================

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClcMessages {
    /// client info (table CRC etc)    
    ClcClientInfo = 8,
    /// [CUserCmd]     
    ClcMove = 9,
    /// Voicestream data from a client    
    ClcVoiceData = 10,
    /// client acknowledges a new baseline seqnr   
    ClcBaselineAck = 11,
    /// client acknowledges a new baseline seqnr   
    ClcListenEvents = 12,
    /// client is responding to a svc_GetCvarValue message.  
    ClcRespondCvarValue = 13,
    /// client is sending a file's CRC to the server to be verified.
    ClcFileCrcCheck = 14,
    /// client loading progress  
    ClcLoadingProgress = 15,
    ClcSplitPlayerConnect = 16,
    ClcClientMessage = 17,
    ClcCmdKeyValues = 18,
    ClcHltvReplay = 20,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VoiceDataFormatT {
    /// steam uses SILK
    VoicedataFormatSteam = 0,
    /// was speex, switching to celt
    VoicedataFormatEngine = 1,
}
//=============================================================================
// Server messages
//=============================================================================

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ESplitScreenMessageType {
    MsgSplitscreenAdduser = 0,
    MsgSplitscreenRemoveuser = 1,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SvcMessages {
    /// first message from server about game; map etc
    SvcServerInfo = 8,
    /// sends a sendtable description for a game class
    SvcSendTable = 9,
    /// Info about classes (first byte is a CLASSINFO_ define).
    SvcClassInfo = 10,
    /// tells client if server paused or unpaused
    SvcSetPause = 11,
    /// inits shared string tables
    SvcCreateStringTable = 12,
    /// updates a string table
    SvcUpdateStringTable = 13,
    /// inits used voice codecs & quality
    SvcVoiceInit = 14,
    /// Voicestream data from the server
    SvcVoiceData = 15,
    /// print text to console
    SvcPrint = 16,
    /// starts playing sound
    SvcSounds = 17,
    /// sets entity as point of view
    SvcSetView = 18,
    /// sets/corrects players viewangle
    SvcFixAngle = 19,
    /// adjusts crosshair in auto aim mode to lock on traget
    SvcCrosshairAngle = 20,
    /// add a static decal to the world BSP
    SvcBspDecal = 21,
    /// split screen style message
    SvcSplitScreen = 22,
    /// a game specific message
    SvcUserMessage = 23,
    /// a message for an entity
    SvcEntityMessage = 24,
    /// global game event fired
    SvcGameEvent = 25,
    /// non-delta compressed entities
    SvcPacketEntities = 26,
    /// non-reliable event object
    SvcTempEntities = 27,
    /// only sound indices for now
    SvcPrefetch = 28,
    /// display a menu from a plugin
    SvcMenu = 29,
    /// list of known games events and fields
    SvcGameEventList = 30,
    /// Server wants to know the value of a cvar on the client
    SvcGetCvarValue = 31,
    /// Server paintmap data
    SvcPaintmapData = 33,
    /// Server submits KeyValues command for the client
    SvcCmdKeyValues = 34,
    /// Server submites encrypted data
    SvcEncryptedData = 35,
    /// start or stop HLTV-fed replay
    SvcHltvReplay = 36,
    /// broadcasting a user command
    SvcBroadcastCommand = 38,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReplayEventTypeT {
    /// Cancel any replays in progress
    ReplayEventCancel = 0,
    /// replay the last player death
    ReplayEventDeath = 1,
    /// replay the event specified in the message
    ReplayEventGeneric = 2,
    /// the client is stuck , the full frame update was somehow discarded at netchan level (reason unknown as of end of 2015), and a new full update is requested
    ReplayEventStuckNeedFullUpdate = 3,
}
