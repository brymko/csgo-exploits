pub struct BitWriter {
    w: usize,
    data: Vec<u8>,
}

impl BitWriter {
    pub fn new() -> Self {
        BitWriter {
            w: 0,
            data: Vec::new(),
        }
    }

    pub fn finish(self) -> Vec<u8> {
        self.data
    }

    pub fn write_char(&mut self, val: u8) {
        self.write_u8(val);
    }

    pub fn write_byte(&mut self, val: u8) {
        self.write_u8(val);
    }

    pub fn write_u8(&mut self, val: u8) {
        // if buffer is 8 bit aligned we can push directly
        let bits_used = self.w & 7;
        if bits_used == 0 {
            self.data.push(val);
        } else {
            // UNWRAP: the only case this wouldn't return smth is if self.w == 0 and we check that
            // above
            let mut last = self.data.last_mut().unwrap();
            let free = 8 - bits_used;
            *last |= (val << bits_used);
            self.data.push(val >> free);
        }

        self.w += 8;
    }

    pub fn write_short(&mut self, sh: i16) {
        sh.to_ne_bytes().iter().for_each(|b| {
            self.write_u8(*b);
        });
    }

    pub fn write_long_long(&mut self, val: i64) {
        val.to_ne_bytes().iter().for_each(|b| {
            self.write_u8(*b);
        });
    }

    pub fn write_str(&mut self, s: &str) {
        s.bytes().for_each(|b| {
            self.write_u8(b);
        });
        self.write_u8(0);
    }

    pub fn write_long(&mut self, s: i32) {
        s.to_ne_bytes().iter().for_each(|b| {
            self.write_u8(*b);
        });
    }

    pub fn write_bit(&mut self, b: u8) {
        let bits_used = self.w & 7;
        if bits_used == 0 {
            self.data.push(b & 1);
        } else {
            // UNWRAP: the only case this wouldn't return smth is if self.w == 0 and we check that
            // above
            let mut last = self.data.last_mut().unwrap();
            *last |= ((b & 1) << bits_used);
        }
        self.w += 1;
    }

    pub fn write_bits(&mut self, num_bits: u8, bits: u8) {
        for i in 0..num_bits {
            self.write_bit(bits >> i);
        }
    }

    pub fn write_var_int32(&mut self, mut val: i32) {
        self.write_bits(7, (val & 0x7f) as u8);
        val >>= 7;
        while val != 0 {
            self.write_bit(0);
            self.write_bits(7, (val & 0x7f) as u8);
            val >>= 7;
        }
        self.write_bit(1);
    }
}

#[derive(Clone)]
pub struct BitReader<'a> {
    r: usize,
    l: usize,
    data: &'a [u8],
}

impl<'a> BitReader<'a> {
    pub fn new(data: &'a [u8]) -> Self {
        BitReader {
            data,
            r: 0,
            l: data.len() * 8,
        }
    }

    pub fn num_bits_read(&self) -> usize {
        self.r
    }

    pub fn read_var_int32(&mut self) -> Option<i32> {
        let mut b = 0;
        let mut res = 0i32;

        for i in 0..4 {
            b = self.read_ubit_long(8)? as i32;
            res |= (b & 0x7f) << (7 * i);

            if (b & 0x80) == 0 {
                break;
            }
        }

        Some(res)
    }

    pub fn read_string(&mut self) -> Option<String> {
        let mut ba = Vec::default();

        loop {
            let b = self.read_ubit_long(8)? as u8;

            ba.push(b);

            if b == 0 || b == 0xa {
                break;
            }
        }

        String::from_utf8(ba).ok()
    }

    pub fn read_bytes(&mut self, len: usize) -> Option<Vec<u8>> {
        if self.l < len * 8 {
            return None;
        }

        let mut ret = Vec::with_capacity(len);

        for i in 0..len {
            let tmp = self.read_byte()?;
            ret.push(tmp);
        }

        Some(ret)
    }

    pub fn read_byte(&mut self) -> Option<u8> {
        self.read_ubit_long(8).map(|val| val as u8)
    }

    pub fn num_bits_left(&self) -> usize {
        self.l
    }

    pub fn read_one_bit(&mut self) -> Option<u8> {
        let current_idx = self.r / 8;
        if self.l < 1 {
            return None;
        }

        let b = self.data[current_idx];
        let ret = Some((b >> (self.r & 7)) & 1);

        self.r += 1;
        self.l -= 1;

        ret
    }

    pub fn read_ubit_long(&mut self, bits: usize) -> Option<u32> {
        if self.l < bits {
            // TODO: return Some(0) all the time
            return None;
        }

        let mut ret = 0u32;

        for i in 0..bits {
            ret |= (self.read_one_bit()? as u32) << i;
        }

        Some(ret)
    }

    pub fn read_short(&mut self) -> Option<i16> {
        if self.l < 16 {
            return None;
        }

        let mut ret = 0;

        for i in 0..16 {
            ret |= (self.read_one_bit()? as i16) << i;
        }

        Some(ret)
    }

    pub fn peek_long(&mut self) -> Option<i32> {
        let res = self.read_long()?;
        self.l += 32;
        self.r -= 32;
        Some(res)
    }

    pub fn read_long(&mut self) -> Option<i32> {
        if self.l < 32 {
            return None;
        }

        let mut ret = 0i32;

        for i in 0..32 {
            ret |= (self.read_one_bit()? as i32) << i;
        }

        Some(ret)
    }
}

impl Iterator for BitReader<'_> {
    // This signifies a bit.
    type Item = u8;

    fn next(&mut self) -> Option<u8> {
        self.read_one_bit()
    }
}
