import os
import sys
current_path = os.getcwd()
parent_dir = os.path.normpath(os.path.join(current_path, "../.."))
sys.path.append(parent_dir)
from exception import Ex


class BitReader:
    def __init__(self, data):
        self.data = data
        self.r = 0
        self.l = len(data) * 8

    def __str__(self):
        return (f"{[x for x in self.data]} {self.r} {self.l}")

    def num_bits_read(self):
        return self.r

    def read_var_int32(self):
        b = 0
        res = 0

        for i in range(0, 4):
            b = self.read_ubit_long(8)
            res |= (b & 0x7f) << (7 * i)

            if (b & 0x80) == 0:
                break

        return res

    def read_string(self):
        s = ""

        while True:
            c = self.read_ubit_long(8)
            if c == 0 or c == 0xa:
                break
            s += chr(c)

        return s

    def read_bytes(self, size):
        if self.l < size * 8:
            # print(f"self.l < size * 8 :: {self.l} < {size} * 8")
            # raise Ex("self.l < size * 8")
            size = self.l // 8

        res = bytes(0)
        for _ in range(size):
            c = self.read_ubit_long(8)
            res += bytes([c])

        return res

    def read_byte(self):
        return bytes([self.read_ubit_long(8)])
        
    def num_bits_left(self):
        return self.l

    def read_one_bit(self):
        cur_idx = self.r // 8
        if self.l < 1:
            # fix for peek from stuff
            self.r += 1
            self.l -= 1
            return 0

        b = self.data[cur_idx]
        ret = (b >> (self.r % 8)) & 1
        self.r += 1
        self.l -= 1

        return ret

    def read_ubit_long(self, bits):
        ret = 0
        for i in range(bits):
            ret |= (self.read_one_bit() << i)

        return ret

    def peek_byte(self):
        val = self.read_byte()
        self.l += 8
        self.r -= 8
        return val

    def peek_long(self):
        val = self.read_long()
        self.l += 32
        self.r -= 32
        return val

    def read_long(self):
        if self.l < 32:
            # print(Ex("self.l < 32"))
            return 0

        val = self.read_ubit_long(32)
        if val & (1 << 31):
            val = val - (1 << 32) 
        return val

    def finish_to_string(self):
        res = b""
        while self.l > 0:
            res += self.read_byte()
        return res
    
    def peek_to_string(self):
        res = self.finish_to_string()
        self.r -= len(res) * 8
        self.l += len(res) * 8
        return res

    def print_left(self):
        print(f"{[x for x in self.peek_to_string()]}")
