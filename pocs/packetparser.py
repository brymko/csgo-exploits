import struct
import os
import sys

current_path = os.getcwd()
parent_dir = os.path.normpath(os.path.join(current_path, "../.."))
sys.path.append(parent_dir)
import netmessages_pb2 as nmsg
import ice as ice
import bitwriter
import bitreader
from exception import Ex

FRAGMENT_BITS = 8
FRAGMENT_SIZE = (1 << FRAGMENT_BITS)
MAX_FILESIZE_BITS = 26 
MAX_FILESIZE = ((1 << MAX_FILESIZE_BITS) - 1)
NET_MAX_PAYLOAD_BITS = 18

def BYTES2FRAGMENT(b):
    return (b + FRAGMENT_SIZE - 1) // FRAGMENT_SIZE

class DataFragment:
    def __init__(self):
        self.filename = ""
        self.buffer = bytearray(0)
        self.num_bytes = 0
        self.num_bits = 0
        self.transferid = 0
        self.is_compressed = False
        self.uncompressed_size = 0
        self.num_fragments = 0
        self.acked_fragments = 0
        self.pending_framgents = 0

def unpad(data):
    num_rand_fudge = data[0]
    if num_rand_fudge > 0 and num_rand_fudge + 5 < len(data):
        num_bytes_written = struct.unpack(">I", data[num_rand_fudge + 1:num_rand_fudge + 5])[0]
        if num_rand_fudge + 5 + num_bytes_written == len(data):
            return data[num_rand_fudge + 5:num_rand_fudge + 5 + num_bytes_written]

    raise Ex("failure during unpadding of data")

class NetMessage:
    def parse(self, reader):
        self = self
        reader = reader
        raise Ex("Default impl")

    def parse_buffer(self, reader):
        size = reader.read_var_int32()
        return reader.read_bytes(size)

class CNETMsg_Tick(NetMessage):
    def parse(self, reader):
        msg = nmsg.CNETMsg_Tick()
        res = msg.ParseFromString(reader.finish_to_string())
        return msg

class CNETMsg_NOP(NetMessage):
    def parse(self, reader):
        self.parse_buffer(reader)
        return self

class CNETMsg_Disconnect(NetMessage):
    def parse(self, reader):
        buff = self.parse_buffer(reader)
        msg = nmsg.CNETMsg_Disconnect()
        bytes_read = msg.ParseFromString(buff)
        return msg

class CNETMsg_SplitScreenUser(NetMessage):
    def parse(self, reader):
        buff = self.parse_buffer(reader)
        # msg = nmsg.CNETMsg_SplitScreenUser()
        # bytes_read = msg.ParseFromString(buff)
        # return msg

class CLCListenEvents(NetMessage):
    def parse(self, reader):
        msg = nmsg.CCLCMsg_ListenEvents()
        buff = self.parse_buffer(reader)
        # res = msg.ParseFromString(buff)
        # print(res)
        # return msg

class PacketParser:
    def __init__(self, leak_callback):
        self.ice = ice.IceKey(2, [0x43, 0x53, 0x47, 0x4F, 0xCF, 0x35, 0x00, 0x00, 0x73, 0x0D, 0x00, 0x00, 0x5C, 0x03, 0x00, 0x00])
        self.binder = {
                # 0: CNETMsg_NOP(),
                1: CNETMsg_Disconnect(),
                3: CNETMsg_SplitScreenUser(),
                4: CNETMsg_Tick(),
                12: CLCListenEvents()
        }
        self.cb_leak_data = leak_callback
        self.subchans = [DataFragment(), DataFragment()]
        self.rel_state = 0

    def read_subchanneldata(self, reader, subchanid):
        start_fragment = 0
        num_fragments = 0
        offset = 0
        length = 0
        df = self.subchans[subchanid]

        single_block = reader.read_one_bit() == 0

        if not single_block:
            start_fragment = reader.read_ubit_long(MAX_FILESIZE_BITS - FRAGMENT_BITS)
            num_fragments = reader.read_ubit_long(3)
            offset = start_fragment * FRAGMENT_SIZE
            length = num_fragments * FRAGMENT_SIZE
            # print(f"{start_fragment} {num_fragments}")

        if offset == 0:
            if not single_block:
                is_file = reader.read_one_bit()
                if is_file:
                    df.transferid = reader.read_ubit_long(32)
                    # TODO(brymko): in the original source this is limited to OS_MAXPATH
                    # however i think we can trust the client to not send bogus values
                    # worst case the reader gets corrupted
                    df.filename = reader.read_string()
                    if reader.read_one_bit():
                        pass # demo playback, don't care
                
                is_compressed = reader.read_one_bit()
                if is_compressed:
                    df.is_compressed = True
                    df.uncompressed_size = reader.read_ubit_long(MAX_FILESIZE_BITS)
                else:
                    df.is_compressed = False
                df.num_bytes = reader.read_ubit_long(MAX_FILESIZE_BITS)

            else:
                is_compressed = reader.read_one_bit()
                if is_compressed:
                    df.is_compressed = True
                    df.uncompressed_size = reader.read_ubit_long(NET_MAX_PAYLOAD_BITS)
                else:
                    df.is_compressed = False
                df.num_bytes = reader.read_ubit_long(NET_MAX_PAYLOAD_BITS)


            if len(df.buffer) > 0:
                # print(reader)
                df.buffer = bytearray()
                raise Ex("Last transmission was aborted, can this happen?")

            df.num_bits = df.num_bytes * 8
            df.num_fragments = BYTES2FRAGMENT(df.num_bytes)
            if df.num_fragments == 0:
                # print(reader)
                raise Ex("Got 0 num frags")
            df.acked_fragments = 0

            if single_block:
                num_fragments = df.num_fragments
                length = num_fragments * FRAGMENT_SIZE

        elif subchanid == 1:
            # TODO(brymko): this is hacky, the file header is somewhere in a prior packet & we don't parse that one correctly
            # For the leak to work however we might take this L and use the file memory anyway
            # So if we are in the file subchannel discard this error
            # raise Ex("Offset=0 never received, this should not happen without parsing issues with the official client")
            # UPDATE: looks like we parse the header correctly now but we don't care about the integrety of the file anyways
            pass
        else:
            raise Ex("Offset=0 never received, this should not happen without parsing issues with the official client")


        if (start_fragment + num_fragments) == df.num_fragments:
            rest = FRAGMENT_SIZE - (df.num_bytes % FRAGMENT_SIZE)
            if rest < FRAGMENT_SIZE:
                length -= rest
        elif (start_fragment + num_fragments) > df.num_fragments:
            raise Ex("Fragment chunk out of bounds, this should not happen with the official client")
        
        buff = reader.read_bytes(length)
        df.buffer[offset:] = buff
        # print(f"buffer len {len(df.buffer)}")
        df.acked_fragments += num_fragments

        self.subchans[subchanid] = df
        return True

    def check_recving_list(self, subchanidx):
        df = self.subchans[subchanidx]

        if len(df.buffer) == 0:
            return False
        if df.acked_fragments < df.num_fragments: #brymko: hack so that we pass every fragment to out callback#  or df.acked_fragments < df.num_fragments:
            print(f"fragments state: {df.acked_fragments}/{df.num_fragments}")
            return False

        if subchanidx != 1:
            if df.acked_fragments > df.num_fragments:
                raise Ex("Too many fragments, this should not happen with the official client && we parse correctly")

            if df.is_compressed:
                raise Ex("TODO: data is compressed")

            if len(df.filename) == 0:
                reader = bitreader.BitReader(df.buffer)
                self.process_message(reader)
            else:
                raise Ex("TODO: filetransport")
        else:
            # again no checks for the file transfer, and delegate to leak callback
            # also return True to reset the DataTransfer struct
            print(f"fragments state: {df.acked_fragments}:{df.num_fragments}")
            self.cb_leak_data(df.filename, df.buffer)
        return True

    def process_message(self, reader):
        cmd = reader.read_var_int32()
        if cmd == 0: return
        try:
            msg = self.binder[cmd].parse(reader)
        except:
            # msg not handled
            # print(f"[-] Msg {cmd} not handled")
            return False
        if msg:
            # print(msg)
            return True


    def on_packet(self, packet):
        packet = [b for b in packet]
        reader = bitreader.BitReader(packet)

        magic = reader.read_long()
        if magic == -2:
            raise Ex("Got split header, not parsing rn")

        if magic == -1:
            raise Ex("Connectionless packet, should not happen")

        decrypted = self.ice.Decrypt(packet)
        decrypted = unpad(decrypted)
        reader = bitreader.BitReader(decrypted)

        magic = reader.peek_long()
        if magic == -3:
            raise Ex("Got compressed packet, not parsing rn")

        if magic == -1:
            raise  Ex("Got connectionless packet in channel packet data")

        return self.on_packet_decrypted(decrypted)

    def on_packet_decrypted(self, buff):
        reader = bitreader.BitReader(buff)
        # finish NET_GetPacket

        seq_nr = reader.read_long()
        ack_nr = reader.read_long()
        flags = reader.read_byte()[0]

        crc = reader.read_ubit_long(16)
        rel_state = reader.read_byte()[0]
        if flags & (1 << 4) != 0:
            choked = reader.read_byte()[0]

        # print()
        # print(f"seq_nr: {seq_nr} ack_nr: {ack_nr} flags: {flags} crc: {hex(crc)} rel_state: {rel_state}")

        # reader.print_left()
        bit = 0
        if flags & (1 << 0) != 0:
            bit = reader.read_ubit_long(3)
            self.rel_state ^= (1 << bit)
            has_regular_data = False
            has_file_data = False
            for i in range(2):
                # 0 == regular stream
                # 1 == file stream
                if i == 1 and has_regular_data: #and not has_regular_data:
                    # TODO(brymko): wtf
                    reader.read_one_bit()
                if reader.read_one_bit():
                    if i == 0:
                        has_regular_data = True
                    if i == 1:
                        has_file_data = True
                    if not self.read_subchanneldata(reader, i):
                        raise Ex("error reading fragments")
            for i in range(2):
                if self.check_recving_list(i):
                    self.subchans[i] = DataFragment()

            assert(self.rel_state < 256)
            if has_file_data:
                return seq_nr, self.rel_state
            # return seq_nr, self.rel_state 
        # check if we have to ack the file
        # print(hex(self.rel_state))
        # df = self.subchans[1]
        # if df.acked_fragments % 8 == 0 and df.acked_fragments > 0 or bit != 0 and (self.rel_state == 0xff or self.rel_state == 0): 
        #     return seq_nr, bit 
        return None, None

        # while reader.num_bits_left() > 8:
        #     # print(f"leftover: {[x for x in reader.peek_to_string()]}")
        #     self.process_message(reader)




